\documentclass[language=polish,type=master]{aghmodern}

\titleEN{Minimizing interaction delay in collaborative web applications}
\titlePL{Minimalizacja opóźnienia w interakcji użytkowników korzystających z aplikacji webowych}
\author{Piotr Szczygieł}
\faculty{Wydział Informatyki, Elektroniki i Telekomunikacji}
\department{Instytut Informatyki}
\supervisor{dr inż. Łukasz Czekierda}
\degreeprogramme{Informatyka}
\degreetype{Stacjonarne}
\date{2022}
\dedication{Test}

\usepackage[backend=biber,doi=true,url=false]{biblatex}
\addbibresource{bibliography.bib}

\setminted{autogobble,breaklines,frame=single,fontsize=\footnotesize}
\definecolor{number}{RGB}{102, 102, 102}
\definecolor{type}{RGB}{176, 0, 64}

\begin{document}

\frontmatter
\maketitle

\setcounter{tocdepth}{1}
\tableofcontents

\mainmatter

\onehalfspacing

\chapter{Wstęp}
TODO: wstęp...

\section{Cel}
Celem pracy jest stworzenie zbioru rekomendacji dla programistów tworzących interaktywne aplikacje webowe.
Rekomendacje będą dotyczyć trzech sfer.
Pierwszą z nich jest kwestia używania WebAssembly w nowych i istniejących aplikacjach.
Przedstawi ona przypadki, w których WebAssembly nie pomoże wydajności naszej aplikacji.
Pokaże również te, gdzie użycie WebAssembly znacząco poprawi wydajność i responsywność danej strony.
Kolejna rekomendacja dotyczyć będzie wyboru języka programowania kompilowanego do WebAssembly.
Jeśli programista zdecyduję się już na użycie WebAssembly, będzie musiał wybrać do tego jeszcze język, w którym będzie pracować.
Różnią się one między sobą wygodą użytkowania oraz wydajnością, więc jest to również ważna decyzja.
Ostatnia rekomendacja to wybór protokołu komunikacji sieciowej.
Przedstawi ona wyniki testów opóźnień pomiędzy WebSocket, a WebRTC.
Oprócz tego wyjaśni różnice w wygodzie tworzenia aplikacji z użyciem danego protokołu.
Finalnie więc czytelnik będzie miał pogląd na rekomendowane technologie używane w procesie tworzenia wydajnych i responsywnych aplikacji webowych.

\section{Motywacja}
Większość ludzi posiadających dostęp do internetu każdego dnia korzysta z różnego rodzaju stron internetowych.
W kieszeni posiadamy komputery z procesorami wielokrotnie razy szybszymi niż komputery personalne jeszcze nie tak dawno temu.
Pomimo tego niektóre strony internetowe potrafią ładować się po kilkanaście sekund, a przy próbie interakcji z nimi zachowywać się nieresponsywnie.
Wiele osób jest poirytowanych takim stanem rzeczy i wspomina czasy dużo wolniejszych komputerów, na których aplikacje mimo tego ładowały się szybko i nie zacinały się.
Stan ten spowodowany jest w głównej mierze pewnego rodzaju chaosem panującym w sferze twórców stron internetowych.
Poradniki do tworzenia nawet najprostszych aplikacji zawierają kod zaciągający tysiące bibliotek niepotrzebnie spowalniających ich działanie.
Nowoczesne technologie takie jak WebAssembly kuszą wielu programistów rozwiązaniem tych problemów.
Jednak na tym stadium rozwoju wiele programistów nadal nie wie czy jest to coś wartego ich uwagi.
Aby ułatwić im dokonanie tego wyboru, w tej pracy skupiono się na pokazaniu z jakich technologii skorzystać, aby przyspieszyć działanie współczesnych aplikacji webowych.

\section{Metodologia}
Prace rozpoczęto od zapoznania się z językami kompilowanymi do WebAssembly.
Po wybraniu trzech języków utworzono z ich wykorzystaniem prosty benchmark.
Został on użyty do badań nad wydajnością każdego z języków, a proces tworzenia aplikacji dostarczył informacji o wygodzie pisania w danym języku.
Po wybraniu jednego z języków utworzono szereg innych aplikacji webowych, które dostarczyły więcej informacji o danej technologii.
Pozwalały one zbadać wydajność tego języka w porównaniu z JavaScriptem.
Na koniec zaprojektowano aplikację podchodzącą pod nurt Tactile Internet.
Utworzono ją jednocześnie jako aplikacje webową JavaScript, WebAssembly oraz aplikację natywną.
Do tego dołączono również badania nad WebSocket oraz WebRTC.
Protokoły te mogłyby służyć przykładowo jako kanał komunikacji w tej aplikacji.
Na podstawie otrzymanych wyników wysnuto wnioski oraz utworzono zestaw rekomendacji dla przyszłych programistów interaktywnych aplikacji webowych.


\section{Zawartość pracy}
Dalsza część pracy została rozdzielona na następujące części:

\begin{itemize}
    \item Rozdział 2 -- zawiera przedstawienie aktualnego stanu wiedzy
    \item Rozdział 3 -- przedstawia porównanie języków kompilowanych do WebAssembly
\end{itemize}

\chapter{Aktualny stan wiedzy}
W tym rozdziale przedstawione zostaną badane technologie oraz aktualny stan wiedzy z nimi związany.

\section{Wydajność WebAssembly}
WebAssembly (w skrócie WASM) jest to binarny format instrukcji dla maszyny wirtualnej opartej na stosie.
Został stworzony jako przenośny cel kompilacji dla języków programowania.
Umożliwia tworzenie aplikacji webowych zarówno po stronie klienta jak i serwera.

Maszyna WASM została przystosowana, aby wczytywać programy szybko, jednocześnie zajmując nie więcej pamięci niż jest to konieczne.
Celuje w osiągnięcie natywnej prędkości korzystając z powszechnych możliwości sprzętowych dostępnych na różnych platformach.
Określa bezpieczne pod względem pamięci oraz dostępu z zewnątrz środowisko wykonywalne.

WebAssembly może być współcześnie stosowany jako zastępstwo lub dopełnienie JavaScript w tworzeniu aplikacji webowych.
Przedstawione poniżej pracę poruszają kwestie porównania wydajności WASM z resztą dostępnych rozwiązań.

W pracy \cite{wasm_blazor} \emph{Dawid Suryś}, \emph{Piotr Szłapa} oraz \emph{Maria Skublewska-Paszkowska} prowadzą badania nad wydajnością WASM oraz JavaScript.
Dochodzą do wniosków, że WASM może być szybszy od JavaScript w przypadku aplikacji zawierających dużą ilość obliczeń oraz operacji na zbiorach danych.
Mimo pisania aplikacji WASM nadal jesteśmy zmuszeni do korzystania z JavaScript do wywoływania zapytań sieciowych czy operacji na DOM.
Powoduje to, że takie operacje są wolniejsze w WASM niż w samym JavaScript przez dodatkowy narzut.
Przedstawiony test frameworka Blazor\footnotemark{} pokazał, że jest on wolniejszy niż istniejące popularne frameworki napisane w JavaScript.
\footnotetext{Blazor -- frontend w C\# wykorzystujący WebAssembly (\url{https://blazor.net/})}
Pokazał jednak, że WebAssembly jest na tyle dojrzały, aby stworzyć w nim kompletny i działający projekt.

Praca \cite{wasm_speedyjs} \emph{Micha Reiser} oraz \emph{Luc Bl\"{a}ser} przedstawia projekt \emph{Speedy.js}, który kompiluje wybrane funkcję z języka TypeScript\footnotemark{} do WebAssembly.
\footnotetext{TypeScript -- statycznie typowany nadzbiór JavaScript (\url{https://www.typescriptlang.org/})}
Generuje on również automatycznie kod pozwalający na łatwą integracje z resztą kodu napisanego w TypeScript.
W niektórych przypadkach osiągnięto nawet czterokrotne przyspieszenie dla funkcji skompilowanych do WASM.
Projekt proponuje ciekawą strategie stopniowej transformacji kodu obliczeniowo intensywnego do WebAssembly.

\emph{Abhinav Jangda} i inni w swojej pracy \cite{wasm_native} porównują wydajność WASM z natywnymi aplikacjami.
Wykorzystując \emph{BROWSIX-WASM}\footnotemark{} porównano wydajność programów skompilowanych do aplikacji natywnych oraz WebAssembly.
\footnotetext{BROWSIX -- projekt umożliwiający uruchamianie niezmodyfikowanych plików wykonywalnych systemu Linux w przeglądarce (\url{https://browsix.org/})}
Aplikacje WASM były średnio wolniejsze od natywnych aplikacji o 1.55x dla przeglądarki Chrome i 1.45x dla Firefox.
Główny powód dla którego WASM jest wolniejsze od natywnej aplikacji to gorsza optymalizacja kodu maszynowego.
Spowodowane jest to ograniczeniami wynikającymi ze specyfikacji WebAssembly (np. stack overflow checks, indirect call checks, reserved registers).
Ograniczenia te nie muszą być zawarte w aplikacji natywnej.

Artykuł \cite{wasm_js_bench} napisany przez \emph{David Herrera} i innych zawiera zbiór benchmarków porównujących WASM oraz JS w różnych konfiguracjach.
Dla maszyny z systemem Windows, WebAssembly był około 70\% szybszy dla przeglądarki Chrome, 60\% szybszy dla Firefox i 163\% szybszy dla przeglądarki Edge.
Z tych trzech przeglądarek najlepsze wyniki odniósł Firefox.
Zaskoczeniem był też telefon iPhone 10, który był szybszy niż MacBook Pro 2013.

\emph{Weihang Wang} w swoim artykule \cite{wasm_js_bench2} porównuje WASM i JS dla czasu wykonania i zużycia pamięci różnych programów.
Zauważa, że WebAssembly zużywa dużo więcej pamięci niż JavaScript.
Mimo tego WASM był dużo szybszy od JS dla bardzo małych rozmiarów danych (35.3x średnie przyspieszenie) oraz małych danych (7.67x średnie przyspieszenie).
Natomiast dla większych rozmiarów danych, dzięki \emph{JIT}\footnotemark{}, JavaScript doganiał WASM, a nawet zdarzały się przypadki gdzie WebAssembly był wolniejszy od JS.
\footnotetext{Kompilator JIT -- kompiluje kod w trakcie wykonywania programu, w przeciwieństwie do zwykłych kompilatorów, które robią to przed jego uruchomieniem}
Otrzymane przez niego wyniki pokazują, że optymalizacja \emph{JIT} w Chrome znacząco poprawia wyniki JavaScript, nie mając wpływu na WASM.

\subsection{Wnioski}
WebAssembly jest obiecującą technologią.
Dla wielu przypadków osiągał dużo lepsze wyniki, jeśli chodzi o obliczenia w przeglądarce.
Mimo tego wspomniane prace głównie skupiały się na samej wydajności, a niewiele było poruszonych tematów tworzenia aplikacji.
Wiele benchmarków były to programy napisane w C przeportowane\footnotemark{} do WASM.
\footnotetext{Portowanie -- proces przenoszenia wersji programu komputerowego na inną platformę sprzętową lub programistyczną}
W tej pracy poruszony zostanie natomiast temat tworzenia nowych aplikacji oraz wybór języka kompilowanego do WASM, który się do tego najbardziej aktualnie nadaje.

\section{WebRTC vs WebSocket}
WebRTC to technologia umożliwiająca aplikacjom webowym i stronom internetowym przechwytywać oraz opcjonalnie strumieniować media audio-wizualne.
Pozwala również na wymianę różnorodnych danych pomiędzy przeglądarkami bez konieczności posiadania serwera pośredniczącego.
Pod spodem korzysta z protokołów UDP, TCP oraz SCTP w zależności od ustawień firewall użytkowników oraz rodzaju przesyłanych danych.

WebSocket natomiast to technologia umożliwiająca otwarcie interaktywnej sesji komunikacji pomiędzy przeglądarką a serwerem.
Zapewnia dwukierunkowy kanał wymiany danych poprzez pojedyncze połączenie TCP.
Przedstawione poniżej prace skupiają się na porównaniu tych dwóch protokołów w różnych kontekstach.

\emph{G{\"u}nay Mert Karadogan} w swojej pracy \cite{websocket_webrtc_iot} bada WebRTC oraz WebSocket pod względem użycia ich w IoT\footnotemark{}.
\footnotetext{Internet of Things -- sieć fizycznych obiektów wyposażonych w czujniki i oprogramowanie umożliwiające wymianę danych z innymi urządzeniami za pośrednictwem Internetu}
Wnioskuje on, że zarówno WebSocket jak i WebRTC może zostać użyte do łączenia urządzeń IoT z Internetem.

\emph{Tomasz Karla} i \emph{Jarosław Tarnawski} w pracy \cite{websocket_webrtc_realtime} porównują opóźnienie protokołów WebRTC oraz WebSocket w różnych scenariuszach.
Testowane były przykładowo sieci lokalne, GSM oraz WiFi. Protokół WebRTC zanotował minimalnie mniejsze opóźnienia.
Umożliwił on również komunikacje aplikacji w obrębie sieci lokalnej\footnotemark{}, mimo postawienia strony na publicznym serwerze.
\footnotetext{WebRTC potrafi połączyć się między dwoma przeglądarkami bezpośrednio, jeśli ustawienia Firewall użytkowników na to pozwalają}
Autorzy wnioskują, że oba protokoły jak najbardziej nadają się do tworzenia aplikacji sieciowej.

Praca \cite{websocket_webrtc_streamr} \emph{Santeri Juslenius} analizowała zachowanie protokołów WebRTC oraz WebSocket w sieci \emph{Streamr}, która jest zdecentralizowanym systemem \emph{publish-subscribe}\footnotemark{}.
\footnotetext{Jest to system komunikacji, w którym wysyłane wiadomości mają przypisane pewne kategorie, które odbiorcy mogą subskrybować w celu ich otrzymywania}
Wyniki badań zauważyły, że WebSocket odnosi lepsze rezultaty pod względem opóźnień.
Jednak dla tej konkretnej topologii WebRTC był bardziej użyteczny ze względu na lepsze wyniki dla małych pakietów oraz możliwości połączeń P2P.

\subsection{Wnioski}
Wszystkie prace zgodnie uznają, że oba protokoły nadają się do tworzenia aplikacji sieciowych.
Niektóre mówią o niższych opóźnieniach dla WebRTC, a inne dla WebSocket.
Sprawdzimy to i w tej pracy implementując prostą aplikacje webową.
Mimo tego, że ta praca będzie się skupiać na technologii WebAssembly, to nie zabraknie w niej badania prostoty użycia tych protokołów sieciowych w interaktywnej aplikacji webowej.

\chapter{Języki kompilowane do WebAssembly}
WebAssembly jest binarnym formatem, interpretowanym przez wirtualną maszynę uruchamianą w przeglądarce lub jako niezależną aplikację.
Nie jest on więc językiem programowania samym w sobie.
Może on natomiast być celem kompilacji dla innych języków.
Wybór takiego języka może okazać się równie ważny jak podjęcie decyzji o tym czy w ogóle korzystać z WASM.
Aktualnie dużo języków posiada WebAssembly jako platformę wynikową kompilacji.
W tej pracy jednak skupiono się na trzech językach: Zig, AssemblyScript oraz Rust.
Pierwszym językiem, któremu zostanie poświęcona uwaga w tej pracy jest Zig.
Jest to młody, szybko rozwijający się język, którego celem jest zastąpienie współczesnych użyć języka C.
AssemblyScript został wybrany jako język bardzo zbliżony składnią i użyciem do popularnego TypeScript.
Dzięki niemu programiści stron internetowych mogliby bez dużej ilości nauki tworzyć moduły WebAssembly.
Rust został wybrany ze względu na największą popularność wśród programistów WASM.
Jest w nim też pokładana największa nadzieja jeśli chodzi o przyszłość programowania WebAssembly.
W tym rozdziale przedstawione będzie porównanie tych języków zarówno pod względem wydajności kodu wynikowego jak i ogólnego procesu tworzenia aplikacji.
Pominięto takie języki jak C oraz C++ ze względu na to, że tak samo jak Rust i Zig korzystają z LLVM\footnotemark{} do generowania kodu wynikowego.
\footnotetext{LLVM -- backend dla kompilatorów z którego korzystają różne frontendy dla takich języków jak C, C++, Rust, Zig, Swift i wiele innych (\url{https://llvm.org/})}
Oznacza to, że niekoniecznie będą od nich wydajniejsze, a współcześni programiści starają się odchodzić od korzystania z tych języków w nowych projektach na rzecz nowocześniejszych rozwiązań.
Zaprezentowane zostanie utworzenie dwóch prostych funkcji w każdym z języków -- rekurencyjnego obliczania n-tej liczby ciągu Fibonacciego oraz sortowania tablicy liczb.
Przedstawiona będzie rekurencyjna wersja Fibonacciego zamiast iteracyjnej, ponieważ jest dużo wolniejsza i szybko zapełnia stos, dzięki czemu łatwiej pokazuje różnice w wydajności między językami.

\section{Zig}
Posiłkując się definicją ze strony głównej projektu\footnotemark{}, Zig to język programowania ogólnego przeznaczenia i zestaw narzędzi do utrzymywania solidnego i optymalnego oprogramowania wielokrotnego użytku.
\footnotetext{\url{https://ziglang.org/}}
Próbuję on być nowoczesnym zastępcą języka C, czyli niskopoziomowym kompilowanym językiem, bez ukrytych alokacji pamięci, automatycznej dealokacji i tym podobnych rozwiązań.
Jednocześnie próbuje naprawić główne problemy swojego poprzednika przykładowo wychwytując dużo problemów związanych z bezpieczeństwem już w trakcie kompilacji.

\subsection{Instalacja}
Proces instalacji potrzebnych narzędzi jest bardzo prosty i zajmuję dosłownie minutę.
Pobieramy archiwum ze strony, wypakowujemy i ewentualnie dodajemy folder do zmiennej środowiskowej \emph{PATH}, aby można było kompilować bez podawania pełnej ścieżki do kompilatora.
Zamiast pobierać manualnie, można też skorzystać z menadżera paczek dla naszego systemu operacyjnego.
Pobrany zestaw narzędzi zawiera wszystko co potrzebne do utworzenia modułu WebAssembly.

\subsection{Tworzenie funkcji \emph{fib}}
Możemy więc zacząć tworzyć naszą aplikację rozpoczynając od napisania funkcji rekurencyjnie liczącej n-tą liczbę w ciągu Fibonacciego.

\begin{listing}[H]
    \begin{minted}{zig}
        export fn fib(n: u64) u64 {
            if (n == 1) return 1;
            if (n == 2) return 1;
            return fib(n - 1) + fib(n - 2);
        }
    \end{minted}
    \caption{Funkcja obliczająca n-tą liczbę ciągu Fibonacciego w języku Zig}
\end{listing}

Jak widać składnia jest bardzo zbliżona do języków z rodziny C.
Słowo kluczowe \emph{export} umożliwia wywołanie danej funkcji z poziomu JavaScript.

\subsection{Tworzenie funkcji \emph{sort}}
Utworzymy teraz funkcję, która otrzymuję tablicę z zewnątrz, a następnie ją sortuję.
Pojawia się tutaj jednak pierwszy problem -- zarządzanie pamięcią.
Nie można mianowicie przekazać tabeli bezpośrednio z poziomu kodu napisanego w JavaScript do moduły WebAssembly.
Nasz program napisany w Zig ma jedynie dostęp do swojej pamięci i jest w tzw. piaskownicy\footnotemark{}.
\footnotetext{Piaskownica (ang. sandbox) -- izoluje program od reszty systemu w celu poprawy bezpieczeństwa}
Należy więc udostępnić tą pamięć użytkownikowi, aby mógł przez nią przekazać nam tablicę do posortowania.

% Minted doesn't detect Zig 10_000_000 number correctly and it breaks syntax highlighting
\begin{listing}[H]
    \begin{minted}[escapeinside=||]{zig}
        const std = @import("std");
        const allocator = @import("std").heap.page_allocator;

        var array: []f64 = undefined;

        export fn initialize_array() *f64 {
            array = allocator.alloc(f64, |\textcolor{number}{10\_000\_000}|) catch unreachable;
            return &array[0];
        }

        export fn sort(size: usize) void {
            std.sort.sort(f64, array[0..size], {}, comptime std.sort.asc(f64));
        }
    \end{minted}
    \caption{Kod udostępniający pamięć dla tablicy oraz funkcja ją sortująca}
\end{listing}

Funkcja \emph{initialize\_array} alokuję najpierw 10MB pamięci, a następnie zwraca wskaźnik na początek zaalokowanej tabeli.
Dzięki temu użytkownik będzie mógł ją wypełnić swoimi danymi, a następnie za pomocą funkcji \emph{sort} posortować N pierwszych liczb.
Nie jest to najwygodniejszy sposób pisania kodu operującego na danych przekazywanych z poziomu strony internetowej.
Zostanie przedstawione później jak w prostszy sposób inne języki radzą sobie z tym problemem.

\subsection{Kompilacja}
Możemy teraz skompilować nasz plik, który nazwiemy \emph{main.zig} i utworzyć moduł WebAssembly \emph{zig.wasm} następującym poleceniem:

\begin{minted}{text}
    $ zig build-lib main.zig -target wasm32-freestanding -dynamic -O ReleaseFast -femit-bin=zig.wasm
\end{minted}

Ustawiliśmy poziom optymalizacji \emph{ReleaseFast}, aby uzyskać jak najlepszą wydajność modułu.
Język Zig oprócz kompilacji z poziomu linii poleceń umożliwia również tworzenie bardziej skomplikowanych programów budujących.
Mogą być one napisane również w języku Zig, zamiast w jakimś innym, kompletnie nie związanym z aplikacją języku opisującym proces budowania.
Dzięki temu nie trzeba uczyć się dodatkowych narzędzi takich jak CMake, Make czy wiele innych.
Temat ten jednak wychodzi poza zakres tej pracy.

\section{AssemblyScript}
AssemblyScript jest wyjątkowy pod tym względem, że został zaprojektowany specjalnie dla WebAssembly.
Korzysta ze składni bardzo zbliżonej do języka TypeScript, dzięki czemu programiści stron internetowych nie będą musieli poświęcać dużo czasu na jej naukę.

\subsection{Instalacja}
AssemblyScript w prosty sposób integruje się z istniejącym ekosystem stron internetowych.
Zainstalować go można korzystając z menadżera paczek \emph{npm}.
Cały proces inicjalizacji nowego projektu jest szybki, prosty i dokładnie opisany w oficjalnym wstępie do języka\footnotemark{}.
\footnotetext{\url{https://www.assemblyscript.org/getting-started.html}}

\subsection{Tworzenie funkcji \emph{fib}}
Zaczynamy pisać kod w wygenerowanym pliku \emph{index.ts} od funkcji \emph{fib}.

% Second u64 is not highlighted for some reason
\begin{listing}[H]
    \begin{minted}[escapeinside=||]{typescript}
        export function fib(n: u64): |\textcolor{type}{u64}| {
            if (n == 1) return 1;
            if (n == 2) return 1;
            return fib(n - 1) + fib(n - 2);
        }
    \end{minted}
    \caption{Funkcja obliczająca n-tą liczbę ciągu Fibonacciego w języku AssemblyScript}
\end{listing}

Kod jest praktycznie taki sam jaki można by napisać w języku TypeScript.
Główną różnicą jest użycie typu \emph{u64}, ponieważ WebAssembly wymaga specyfikacji konkretnego typu używanych liczb całkowitych.

\subsection{Tworzenie funkcji \emph{sort}}

Funkcje sort można w tym języku napisać dużo szybciej niż w języku Zig.

\begin{listing}[H]
    \begin{minted}{typescript}
        export function sort(array: Array<f64>): void {
            array.sort();
        }
    \end{minted}
    \caption{Funkcja sortująca tablicę w języku AssemblyScript}
\end{listing}

Jak można zauważyć, wystarczy że ustawimy typ zmiennej wejściowej jako \emph{Array<f64>}, aby funkcja przyjmowała tablicę liczb zmiennoprzecinkowych.
W przeciwieństwie do języka Zig, nie jest konieczne manualnie tworzenie bufora, do którego przekażemy tablice z zewnątrz.
AssemblyScript w trakcie kompilacji automatycznie generuje kod, dzięki któremu nie musimy się tym przejmować.
Tworzona jest funkcja okalająca (ang. wrapper function), która alokuje pamięć dla naszej tablicy i przekazuje ją do właściwej funkcji jako wskaźnik na tą pamięć.

\subsection{Kompilacja}
Skompilować projekt możemy za pomocą narzędzia \emph{npm}.

\begin{minted}{text}
    $ npm run build
\end{minted}

Podczas inicjalizacji projektu wygenerowała się konfiguracja, która powoduje, że to polecenie kompiluje nasz program do modułu WebAssembly.
Co ważne w przypadku tego języku, z racji na ścisłą integrację z resztą ekosystemu tworzenia stron internetowych, buduje to również jednocześnie pozostały kod strony.
Oznacza to, że nie potrzebujemy dodatkowego kroku kompilacji WebAssembly, a wszystko odbywa się z użyciem jednego systemu budującego.
Bardzo przydatną funkcją są również automatycznie generowane pliki typów TypeScript.

\begin{listing}[H]
    \begin{minted}{typescript}
        export declare function fib(n: bigint): bigint;
        export declare function sort(array: Array<number>): void;
    \end{minted}
    \caption{Fragment automatycznie wygenerowanego pliku typów}
\end{listing}

Dzięki nim otrzymujemy podpowiedzi w naszym środowisku programistycznym w trakcie odwoływania się do funkcji napisanych w AssemblyScript.

\section{Rust}

\subsection{Instalacja}

\subsection{Tworzenie funkcji \emph{fib}}

\subsection{Tworzenie funkcji \emph{sort}}

\subsection{Kompilacja}

\section{Porównanie wydajności języków}

\section{Wnioski}

% \chapter{Użytkowanie i wydajność Rust}

% \section{Sumowanie macierzy}

% \subsection{JavaScript}

% \subsection{Rust}

% \subsection{Rust z wykorzystaniem SIMD}

% \section{Symulacja N ciał}

% \subsection{JavaScript}

% \subsection{Rust}

% \section{Wnioski}

% \chapter{Interaktywna aplikacja webowa z użyciem WebAssembly}

% \section{Przykładowa aplikacja}

% \section{Porównanie wydajności}

% \section{Aplikacja natywna}

% \section{WebRTC vs WebSocket}

% \chapter{Podsumowanie}

\backmatter

\cleardoublepage
\listoffigures

\cleardoublepage
\listoftables

\cleardoublepage
\renewcommand\listoflistingscaption{Spis listingów}
\listoflistings

\cleardoublepage
\printbibliography

\end{document}
