\documentclass[language=polish,type=master]{aghmodern}

\titleEN{Minimizing interaction delay in collaborative web applications}
\titlePL{Minimalizacja opóźnienia w interakcji użytkowników korzystających z aplikacji webowych}
\author{Piotr Szczygieł}
\faculty{Wydział Informatyki, Elektroniki i Telekomunikacji}
\department{Instytut Informatyki}
\supervisor{dr inż. Łukasz Czekierda}
\degreeprogramme{Informatyka}
\degreetype{Stacjonarne}
\date{2022}
\dedication{Test}

\usepackage[backend=biber,doi=true,url=false]{biblatex}
\addbibresource{bibliography.bib}

\setminted{autogobble,breaklines,frame=single,fontsize=\footnotesize}
\definecolor{number}{RGB}{102, 102, 102}
\definecolor{type}{RGB}{176, 0, 64}

\begin{document}

\frontmatter
\maketitle

\setcounter{tocdepth}{1}
\tableofcontents

\mainmatter

\onehalfspacing

\chapter{Wstęp}
TODO: wstęp...

\section{Cel}
Celem pracy jest stworzenie zbioru rekomendacji dla programistów tworzących interaktywne aplikacje webowe.
Rekomendacje będą dotyczyć trzech sfer.
Pierwszą z nich jest kwestia używania WebAssembly w nowych i istniejących aplikacjach.
Przedstawi ona przypadki, w których WebAssembly nie pomoże wydajności naszej aplikacji.
Pokaże również te, gdzie użycie WebAssembly znacząco poprawi wydajność i responsywność danej strony.
Kolejna rekomendacja dotyczyć będzie wyboru języka programowania kompilowanego do WebAssembly.
Jeśli programista zdecyduję się już na użycie WebAssembly, będzie musiał wybrać do tego jeszcze język, w którym będzie pracować.
Różnią się one między sobą wygodą użytkowania oraz wydajnością, więc jest to również ważna decyzja.
Ostatnia rekomendacja to wybór protokołu komunikacji sieciowej.
Przedstawi ona wyniki testów opóźnień pomiędzy WebSocket, a WebRTC.
Oprócz tego wyjaśnione zostaną różnice w wygodzie tworzenia aplikacji z użyciem danego protokołu.
Finalnie więc czytelnik będzie miał pogląd na rekomendowane technologie używane w procesie tworzenia wydajnych i responsywnych aplikacji webowych.

\section{Motywacja}
Większość ludzi posiadających dostęp do internetu każdego dnia korzysta z różnego rodzaju stron internetowych.
W kieszeni posiadamy komputery z procesorami wielokrotnie razy szybszymi niż komputery personalne jeszcze nie tak dawno temu.
Pomimo tego niektóre strony internetowe potrafią ładować się po kilkanaście sekund, a przy próbie interakcji z nimi zachowywać się nieresponsywnie.
Wiele osób jest poirytowanych takim stanem rzeczy i wspomina czasy dużo wolniejszych komputerów, na których aplikacje mimo tego ładowały się szybko i nie zacinały się.
Stan ten spowodowany jest w głównej mierze pewnego rodzaju chaosem panującym w sferze twórców stron internetowych.
Poradniki do tworzenia nawet najprostszych aplikacji zawierają kod zaciągający tysiące bibliotek niepotrzebnie spowalniających ich działanie.
Nowoczesne technologie takie jak WebAssembly kuszą wielu programistów rozwiązaniem tych problemów.
Jednak na tym stadium rozwoju wiele programistów nadal nie wie czy jest to coś wartego ich uwagi.
Aby ułatwić im dokonanie tego wyboru, w tej pracy skupiono się na pokazaniu z jakich technologii skorzystać, aby przyspieszyć działanie współczesnych aplikacji webowych.

\section{Metodologia}
Prace rozpoczęto od zapoznania się z językami kompilowanymi do WebAssembly.
Po wybraniu trzech interesujących języków utworzono z ich wykorzystaniem prosty benchmark.
Został on użyty do badań nad wydajnością każdego z języków, a proces tworzenia aplikacji dostarczył informacji o wygodzie pisania w danym języku.
Po wybraniu jednego z języków utworzono inne aplikacje webowe, które dostarczyły więcej informacji o danej technologii.
Pozwalały one zbadać wydajność tego języka w porównaniu z JavaScriptem.
Na koniec zaprojektowano aplikację podchodzącą pod nurt Tactile Internet.
Utworzono ją jednocześnie jako aplikacje webową JavaScript, WebAssembly oraz aplikację natywną.
Do tego dołączono również badania nad WebSocket oraz WebRTC.
Protokoły te mogłyby służyć przykładowo jako kanał komunikacji w tej aplikacji.
Na podstawie otrzymanych wyników wysnuto wnioski oraz utworzono zestaw rekomendacji dla przyszłych programistów interaktywnych aplikacji webowych.


\section{Zawartość pracy}
Dalsza część pracy została rozdzielona na następujące części:

\begin{itemize}
    \item Rozdział 2 -- zawiera przedstawienie aktualnego stanu wiedzy
    \item Rozdział 3 -- przedstawia porównanie języków kompilowanych do WebAssembly
\end{itemize}

\chapter{Aktualny stan wiedzy}
W tym rozdziale przedstawione zostaną badane technologie oraz aktualny stan wiedzy z nimi związany.

\section{Wydajność WebAssembly}
WebAssembly (w skrócie WebAssembly) jest to binarny format instrukcji dla maszyny wirtualnej opartej na stosie.
Został stworzony jako przenośny cel kompilacji dla języków programowania.
Umożliwia tworzenie aplikacji webowych zarówno po stronie klienta jak i serwera.

Maszyna WebAssembly została przystosowana, aby wczytywać programy szybko, jednocześnie zajmując nie więcej pamięci niż jest to konieczne.
Celuje w osiągnięcie natywnej prędkości korzystając z powszechnych możliwości sprzętowych dostępnych na różnych platformach.
Określa bezpieczne pod względem pamięci oraz dostępu z zewnątrz środowisko wykonywalne.

WebAssembly może być współcześnie stosowany jako zastępstwo lub dopełnienie JavaScript w tworzeniu aplikacji webowych.
Przedstawione poniżej pracę poruszają kwestie porównania wydajności WebAssembly z resztą dostępnych rozwiązań.

W pracy \cite{wasm_blazor} \emph{Dawid Suryś}, \emph{Piotr Szłapa} oraz \emph{Maria Skublewska-Paszkowska} prowadzą badania nad wydajnością WebAssembly oraz JavaScript.
Dochodzą do wniosków, że WebAssembly może być szybszy od JavaScript w przypadku aplikacji zawierających dużą ilość obliczeń oraz operacji na zbiorach danych.
Mimo pisania aplikacji WebAssembly nadal jesteśmy zmuszeni do korzystania z JavaScript do wywoływania zapytań sieciowych czy operacji na DOM.
Powoduje to, że takie operacje są wolniejsze w WebAssembly niż w samym JavaScript przez dodatkowy narzut.
Przedstawiony test frameworka Blazor\footnotemark{} pokazał, że jest on wolniejszy niż istniejące popularne frameworki napisane w JavaScript.
\footnotetext{Blazor -- frontend w C\# wykorzystujący WebAssembly (\url{https://blazor.net/})}
Pokazał jednak, że WebAssembly jest na tyle dojrzały, aby stworzyć w nim kompletny i działający projekt.

Praca \cite{wasm_speedyjs} \emph{Micha Reiser} oraz \emph{Luc Bl\"{a}ser} przedstawia projekt \emph{Speedy.js}, który kompiluje wybrane funkcję z języka TypeScript\footnotemark{} do WebAssembly.
\footnotetext{TypeScript -- statycznie typowany nadzbiór JavaScript (\url{https://www.typescriptlang.org/})}
Generuje on również automatycznie kod pozwalający na łatwą integracje z resztą kodu napisanego w TypeScript.
W niektórych przypadkach osiągnięto nawet czterokrotne przyspieszenie dla funkcji skompilowanych do WebAssembly.
Projekt proponuje ciekawą strategie stopniowej transformacji kodu obliczeniowo intensywnego do WebAssembly.

\emph{Abhinav Jangda} i inni w swojej pracy \cite{wasm_native} porównują wydajność WebAssembly z natywnymi aplikacjami.
Wykorzystując \emph{BROWSIX-WASM}\footnotemark{} porównano wydajność programów skompilowanych do aplikacji natywnych oraz WebAssembly.
\footnotetext{BROWSIX -- projekt umożliwiający uruchamianie niezmodyfikowanych plików wykonywalnych systemu Linux w przeglądarce (\url{https://browsix.org/})}
Aplikacje WebAssembly były średnio wolniejsze od natywnych aplikacji o 1.55x dla przeglądarki Chrome i 1.45x dla Firefox.
Główny powód dla którego WebAssembly jest wolniejsze od natywnej aplikacji to gorsza optymalizacja kodu maszynowego.
Spowodowane jest to ograniczeniami wynikającymi ze specyfikacji WebAssembly (np. stack overflow checks, indirect call checks, reserved registers).
Ograniczenia te nie muszą być zawarte w aplikacji natywnej.

Artykuł \cite{wasm_js_bench} napisany przez \emph{David Herrera} i innych zawiera zbiór benchmarków porównujących WebAssembly oraz JavaScript w różnych konfiguracjach.
Dla maszyny z systemem Windows, WebAssembly był około 70\% szybszy dla przeglądarki Chrome, 60\% szybszy dla Firefox i 163\% szybszy dla przeglądarki Edge.
Z tych trzech przeglądarek najlepsze wyniki odniósł Firefox.
Zaskoczeniem był też telefon iPhone 10, który był szybszy niż MacBook Pro 2013.

\emph{Weihang Wang} w swoim artykule \cite{wasm_js_bench2} porównuje WebAssembly i JavaScript dla czasu wykonania i zużycia pamięci różnych programów.
Zauważa, że WebAssembly zużywa dużo więcej pamięci niż JavaScript.
Mimo tego WebAssembly był dużo szybszy od JavaScript dla bardzo małych rozmiarów danych (35.3x średnie przyspieszenie) oraz małych danych (7.67x średnie przyspieszenie).
Natomiast dla większych rozmiarów danych, dzięki \emph{JIT}\footnotemark{}, JavaScript doganiał WebAssembly, a nawet zdarzały się przypadki gdzie WebAssembly był wolniejszy od JavaScript.
\footnotetext{Kompilator JIT -- kompiluje kod w trakcie wykonywania programu, w przeciwieństwie do zwykłych kompilatorów, które robią to przed jego uruchomieniem}
Otrzymane przez niego wyniki pokazują, że optymalizacja \emph{JIT} w Chrome znacząco poprawia wyniki JavaScript, nie mając wpływu na WebAssembly.

\subsection{Wnioski}
WebAssembly jest obiecującą technologią.
Dla wielu przypadków osiągał dużo lepsze wyniki, jeśli chodzi o obliczenia w przeglądarce.
Mimo tego wspomniane prace głównie skupiały się na samej wydajności, a niewiele było poruszonych tematów tworzenia aplikacji.
Wiele benchmarków były to programy napisane w C przeportowane\footnotemark{} do WebAssembly.
\footnotetext{Portowanie -- proces przenoszenia wersji programu komputerowego na inną platformę sprzętową lub programistyczną}
W tej pracy poruszony zostanie natomiast temat tworzenia nowych aplikacji oraz wybór języka kompilowanego do WebAssembly, który się do tego najbardziej aktualnie nadaje.

\section{WebRTC vs WebSocket}
WebRTC to technologia umożliwiająca aplikacjom webowym i stronom internetowym przechwytywać oraz opcjonalnie strumieniować media audio-wizualne.
Pozwala również na wymianę różnorodnych danych pomiędzy przeglądarkami bez konieczności posiadania serwera pośredniczącego.
Pod spodem korzysta z protokołów UDP, TCP oraz SCTP w zależności od ustawień firewall użytkowników oraz rodzaju przesyłanych danych.

WebSocket natomiast to technologia umożliwiająca otwarcie interaktywnej sesji komunikacji pomiędzy przeglądarką a serwerem.
Zapewnia dwukierunkowy kanał wymiany danych poprzez pojedyncze połączenie TCP.
Przedstawione poniżej prace skupiają się na porównaniu tych dwóch protokołów w różnych kontekstach.

\emph{G{\"u}nay Mert Karadogan} w swojej pracy \cite{websocket_webrtc_iot} bada WebRTC oraz WebSocket pod względem użycia ich w IoT\footnotemark{}.
\footnotetext{Internet of Things -- sieć fizycznych obiektów wyposażonych w czujniki i oprogramowanie umożliwiające wymianę danych z innymi urządzeniami za pośrednictwem Internetu}
Wnioskuje on, że zarówno WebSocket jak i WebRTC może zostać użyte do łączenia urządzeń IoT z Internetem.

\emph{Tomasz Karla} i \emph{Jarosław Tarnawski} w pracy \cite{websocket_webrtc_realtime} porównują opóźnienie protokołów WebRTC oraz WebSocket w różnych scenariuszach.
Testowane były przykładowo sieci lokalne, GSM oraz WiFi. Protokół WebRTC zanotował minimalnie mniejsze opóźnienia.
Umożliwił on również komunikacje aplikacji w obrębie sieci lokalnej\footnotemark{}, mimo postawienia strony na publicznym serwerze.
\footnotetext{WebRTC potrafi połączyć się między dwoma przeglądarkami bezpośrednio, jeśli ustawienia Firewall użytkowników na to pozwalają}
Autorzy wnioskują, że oba protokoły jak najbardziej nadają się do tworzenia aplikacji sieciowej.

Praca \cite{websocket_webrtc_streamr} \emph{Santeri Juslenius} analizowała zachowanie protokołów WebRTC oraz WebSocket w sieci \emph{Streamr}, która jest zdecentralizowanym systemem \emph{publish-subscribe}\footnotemark{}.
\footnotetext{Jest to system komunikacji, w którym wysyłane wiadomości mają przypisane pewne kategorie, które odbiorcy mogą subskrybować w celu ich otrzymywania}
Wyniki badań zauważyły, że WebSocket odnosi lepsze rezultaty pod względem opóźnień.
Jednak dla tej konkretnej topologii WebRTC był bardziej użyteczny ze względu na lepsze wyniki dla małych pakietów oraz możliwości połączeń P2P.

\subsection{Wnioski}
Wszystkie prace zgodnie uznają, że oba protokoły nadają się do tworzenia aplikacji sieciowych.
Niektóre mówią o niższych opóźnieniach dla WebRTC, a inne dla WebSocket.
Sprawdzimy to i w tej pracy implementując prostą aplikacje webową.
Mimo tego, że ta praca będzie się skupiać na technologii WebAssembly, to nie zabraknie w niej badania prostoty użycia tych protokołów sieciowych w interaktywnej aplikacji webowej.

\chapter{Języki kompilowane do WebAssembly}
WebAssembly jest binarnym formatem, interpretowanym przez wirtualną maszynę uruchamianą w przeglądarce lub jako niezależną aplikację.
Nie jest on więc językiem programowania samym w sobie.
Może on natomiast być celem kompilacji dla innych języków.
Wybór takiego języka może okazać się równie ważny jak podjęcie decyzji o tym czy w ogóle korzystać z WebAssembly.
Aktualnie dużo języków ma możliwość ustawienia WebAssembly jako platformę wynikową kompilacji.
W tej pracy jednak skupiono się na trzech: Zig, AssemblyScript oraz Rust.
Pierwszym językiem, któremu zostanie poświęcona uwaga w tej pracy jest Zig.
Jest to młody, szybko rozwijający się język, którego celem jest zastąpienie współczesnych użyć języka C.
AssemblyScript został wybrany jako język bardzo zbliżony składnią i użyciem do popularnego TypeScript.
Dzięki niemu programiści stron internetowych mogliby bez dużej ilości nauki tworzyć moduły WebAssembly.
Rust został wybrany ze względu na największą popularność wśród programistów WebAssembly.
Jest w nim też pokładana największa nadzieja jeśli chodzi o przyszłość programowania WebAssembly.
W tym rozdziale przedstawione będzie porównanie tych języków zarówno pod względem wydajności kodu wynikowego jak i ogólnego procesu tworzenia aplikacji.
Pominięto takie języki jak C oraz C++ ze względu na to, że tak samo jak Rust i Zig korzystają z LLVM\footnotemark{} do generowania kodu wynikowego.
\footnotetext{LLVM -- backend dla kompilatorów z którego korzystają różne frontendy dla takich języków jak C, C++, Rust, Zig, Swift i wiele innych (\url{https://llvm.org/})}
Oznacza to, że niekoniecznie będą od nich wydajniejsze, a współcześni programiści starają się odchodzić od korzystania z tych języków w nowych projektach na rzecz nowocześniejszych rozwiązań.
Zaprezentowane zostanie utworzenie dwóch prostych funkcji w każdym z języków -- rekurencyjnego obliczania n-tej liczby ciągu Fibonacciego oraz sortowania tablicy liczb.
Przedstawiona będzie rekurencyjna wersja Fibonacciego zamiast iteracyjnej, ponieważ jest dużo wolniejsza i szybko zapełnia stos, dzięki czemu łatwiej pokazuje różnice w wydajności między językami.

\section{Zig}
Posiłkując się definicją ze strony głównej projektu\footnotemark{}, Zig to język programowania ogólnego przeznaczenia i zestaw narzędzi do utrzymywania solidnego i optymalnego oprogramowania wielokrotnego użytku.
\footnotetext{\url{https://ziglang.org/}}
Próbuję on być nowoczesnym zastępcą języka C, czyli niskopoziomowym kompilowanym językiem, bez ukrytych alokacji pamięci, automatycznej dealokacji i tym podobnych rozwiązań.
Jednocześnie próbuje naprawić główne problemy swojego poprzednika przykładowo wychwytując dużo problemów związanych z bezpieczeństwem już w trakcie kompilacji.

\subsection{Instalacja}
Proces instalacji potrzebnych narzędzi jest bardzo prosty i zajmuję dosłownie minutę.
Pobieramy archiwum ze strony, wypakowujemy i ewentualnie dodajemy folder do zmiennej środowiskowej \emph{PATH}, aby można było kompilować bez podawania pełnej ścieżki do kompilatora.
Zamiast pobierać manualnie, można też skorzystać z menadżera paczek dla naszego systemu operacyjnego.
Pobrany zestaw narzędzi zawiera wszystko co potrzebne do utworzenia modułu WebAssembly.

\subsection{Tworzenie funkcji \emph{fib}}
Można więc zacząć tworzyć aplikację rozpoczynając od napisania funkcji rekurencyjnie liczącej n-tą liczbę w ciągu Fibonacciego.

\begin{listing}[H]
    \begin{minted}{zig}
        export fn fib(n: u64) u64 {
            if (n == 1) return 1;
            if (n == 2) return 1;
            return fib(n - 1) + fib(n - 2);
        }
    \end{minted}
    \caption{Funkcja \emph{fib} w języku Zig}
\end{listing}

Jak widać składnia jest bardzo zbliżona do języków z rodziny C.
Słowo kluczowe \emph{export} umożliwia wywołanie danej funkcji z poziomu JavaScript.

\subsection{Tworzenie funkcji \emph{sort}}
Kolejnym krokiem jest utworzenie funkcji, która otrzymuję tablicę z zewnątrz, a następnie ją sortuję.
Pojawia się tutaj jednak pierwszy problem -- zarządzanie pamięcią.
Nie można mianowicie przekazać tablicy bezpośrednio z poziomu kodu napisanego w JavaScript do modułu WebAssembly.
Program napisany w Zig ma jedynie dostęp do swojej pamięci i jest w tzw. piaskownicy\footnotemark{}.
\footnotetext{Piaskownica (ang. sandbox) -- izoluje program od reszty systemu w celu poprawy bezpieczeństwa}
Należy więc udostępnić tą pamięć użytkownikowi, aby mógł przez nią przekazać nam tablicę do posortowania.

% Minted doesn't detect Zig 10_000_000 number correctly and it breaks syntax highlighting
\begin{listing}[H]
    \begin{minted}[escapeinside=||]{zig}
        const std = @import("std");
        const allocator = @import("std").heap.page_allocator;

        var array: []f64 = undefined;

        export fn initialize_array() *f64 {
            array = allocator.alloc(f64, |\textcolor{number}{10\_000\_000}|) catch unreachable;
            return &array[0];
        }

        export fn sort(size: usize) void {
            std.sort.sort(f64, array[0..size], {}, comptime std.sort.asc(f64));
        }
    \end{minted}
    \caption{Funkcja \emph{sort} i jej kod pomocniczy w języku Zig}
\end{listing}

Funkcja \emph{initialize\_array} alokuję najpierw 10MB pamięci, a następnie zwraca wskaźnik na początek zaalokowanej tablicy.
Dzięki temu użytkownik będzie mógł ją wypełnić swoimi danymi, a następnie za pomocą funkcji \emph{sort} posortować N pierwszych liczb.
Nie jest to najwygodniejszy sposób pisania kodu operującego na danych przekazywanych z poziomu strony internetowej.
Zostanie przedstawione później jak w prostszy sposób inne języki radzą sobie z tym problemem.

\subsection{Kompilacja}
Można teraz skompilować plik, który nazwany został \emph{main.zig} i utworzyć moduł WebAssembly \emph{zig.wasm} następującym poleceniem:

\begin{minted}{console}
    $ zig build-lib main.zig -target wasm32-freestanding -dynamic -O ReleaseFast -femit-bin=zig.wasm
\end{minted}

Ustawiono poziom optymalizacji na \emph{ReleaseFast}, aby uzyskać jak najlepszą wydajność modułu.
Język Zig oprócz kompilacji z poziomu linii poleceń umożliwia również tworzenie bardziej skomplikowanych programów budujących.
Mogą być one napisane również w języku Zig, zamiast w jakimś innym, kompletnie nie związanym z aplikacją języku opisującym proces budowania.
Dzięki temu nie trzeba uczyć się dodatkowych narzędzi takich jak CMake, Make czy wiele innych.
Temat ten jednak wychodzi poza zakres tej pracy.

\section{AssemblyScript}
AssemblyScript jest wyjątkowy pod tym względem, że został zaprojektowany specjalnie dla WebAssembly.
Korzysta ze składni bardzo zbliżonej do języka TypeScript, dzięki czemu programiści stron internetowych nie muszą poświęcać dużo czasu na jej naukę.

\subsection{Instalacja}
AssemblyScript w prosty sposób integruje się z istniejącym ekosystemem stron internetowych.
Zainstalować go można korzystając z menadżera paczek \emph{npm}.
Cały proces inicjalizacji nowego projektu jest szybki, prosty i dokładnie opisany w oficjalnym wstępie do języka\footnotemark{}.
\footnotetext{\url{https://www.assemblyscript.org/getting-started.html}}

\subsection{Tworzenie funkcji \emph{fib}}
Pisanie kodu rozpoczęto w wygenerowanym pliku \emph{index.ts} od funkcji \emph{fib}.

% Second u64 is not highlighted for some reason
\begin{listing}[H]
    \begin{minted}[escapeinside=||]{typescript}
        export function fib(n: u64): |\textcolor{type}{u64}| {
            if (n == 1) return 1;
            if (n == 2) return 1;
            return fib(n - 1) + fib(n - 2);
        }
    \end{minted}
    \caption{Funkcja \emph{fib} w języku AssemblyScript}
\end{listing}

Kod jest praktycznie taki sam jaki można by napisać w języku TypeScript.
Główną różnicą jest użycie typu \emph{u64}, ponieważ WebAssembly wymaga specyfikacji konkretnego typu liczby obsługiwanego przez maszynę wirtualną.

\subsection{Tworzenie funkcji \emph{sort}}

Funkcje sort można w tym języku napisać dużo szybciej niż w języku Zig.

\begin{listing}[H]
    \begin{minted}{typescript}
        export function sort(array: Array<f64>): void {
            array.sort();
        }
    \end{minted}
    \caption{Funkcja \emph{sort} w języku AssemblyScript}
\end{listing}

Jak można zauważyć, wystarczy że ustawimy typ zmiennej wejściowej jako \emph{Array<f64>}, aby funkcja przyjmowała tablicę liczb zmiennoprzecinkowych.
W przeciwieństwie do języka Zig, nie jest konieczne manualnie tworzenie bufora, do którego przekażemy tablice z zewnątrz.
AssemblyScript w trakcie kompilacji automatycznie generuje kod, dzięki któremu nie musimy się tym przejmować.
Tworzona jest funkcja okalająca (ang. wrapper function), która alokuje pamięć dla naszej tablicy i przekazuje ją do właściwej funkcji jako wskaźnik na tą pamięć.

\subsection{Kompilacja}
Skompilować projekt możemy za pomocą narzędzia \emph{npm}.

\begin{minted}{console}
    $ npm run build
\end{minted}

Podczas inicjalizacji projektu wygenerowała się konfiguracja, która powoduje, że to polecenie kompiluje nasz program do modułu WebAssembly.
Co ważne w przypadku tego języku, z racji na ścisłą integrację z resztą ekosystemu tworzenia stron internetowych, buduje to również jednocześnie pozostały kod strony.
Oznacza to, że nie potrzebujemy dodatkowego kroku kompilacji WebAssembly, a wszystko odbywa się z użyciem jednego systemu budującego.
Bardzo przydatną funkcją są również automatycznie generowane pliki typów TypeScript.

\begin{listing}[H]
    \begin{minted}{typescript}
        export declare function fib(n: bigint): bigint;
        export declare function sort(array: Array<number>): void;
    \end{minted}
    \caption{Fragment wygenerowanego pliku typów AssemblyScript}
\end{listing}

Dzięki nim otrzymywano podpowiedzi w środowisku programistycznym w trakcie odwoływania się do funkcji napisanych w AssemblyScript.

\section{Rust}
Rust, podobnie jak Zig jest językiem programowania ogólnego przeznaczenia.
Stworzony został z myślą o bezpieczeństwie, współbieżności i praktyczności.
Według corocznej ankiety serwisu Stack Overflow\footnotemark{}, Rust jest najbardziej lubianym językiem programowania od 2015 roku.
\footnotetext{\url{https://insights.stackoverflow.com/survey/}}

\subsection{Instalacja}
Rust można zainstalować korzystając z menadżera paczek systemu operacyjnego lub skorzystać z programu \emph{rustup}\footnotemark{}, który szybko przeprowadzi użytkownika przez kolejne kroki instalacji.
\footnotetext{\url{https://rustup.rs/}}
Instalacja na systemie Windows wymaga również zainstalowania Microsoft Visual Studio dla języka C++.
Po zainstalowaniu języka możemy przystąpić do tworzenia nowego projektu.
Książka \emph{Rust and WebAssembly}\footnotemark{} prezentuje krok po kroku ten proces.
\footnotetext{\url{https://rustwasm.github.io/}}
Jest on prosty i zrozumiały, co ważne pokazuję też jak w prosty sposób integrować utworzone moduły ze stronami internetowymi.

\subsection{Tworzenie funkcji \emph{fib}}
Po przygotowaniu środowiska można rozpocząć edycję pliku \emph{lib.rs}.

\begin{listing}[H]
    \begin{minted}{rust}
        #[wasm_bindgen]
        pub fn fib(n: u64) -> u64 {
            match n {
                1 => 1,
                2 => 1,
                _ => fib(n - 1) + fib(n - 2)
            }
        }
    \end{minted}
    \caption{Funkcja \emph{fib} w języku Rust}
\end{listing}

Jak widać, poza specyficzną dyrektywą \emph{match}, kod powinien być zrozumiały dla większości programistów.
W języku Rust ostatnie wyrażenie w funkcji uznawane jest jako wartość zwracana, a dyrektywa \emph{match} działa podobnie jak \emph{switch} w językach z rodziny C.
Atrybut \emph{wasm\_bindgen} oznacza funkcje jako dostępną do wywołania z poziomu strony internetowej.
Jest to wymagane, dlatego że oprócz modułu WebAssembly, automatycznie generowany będzie również kod JavaScript inicjalizujący ten moduł oraz dodający funkcje pomocnicze.
Podobne rozwiązanie mogliśmy zauważyć w projekcie AssemblyScript, a brak jego jest odczuwalny tworząc projekt w języku Zig.

\subsection{Tworzenie funkcji \emph{sort}}
Przekazywanie tablicy do modułu WebAssembly można zrobić na różne sposoby.
Jeden z nich jest przedstawiony poniżej.

\begin{listing}[H]
    \begin{minted}{rust}
        #[wasm_bindgen]
        pub fn sort(js_array: &Float64Array) {
            let mut numbers: Vec<f64> = js_array.to_vec();
            numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());
        }
    \end{minted}
    \caption{Funkcja \emph{sort} w języku Rust}
\end{listing}

Przekazaną z poziomu JavaScript tablicę konwertujemy na natywny dla języka Rust typ \emph{Vec}, który określa dynamiczną tablicę.
Może to spowodować mały narzut czasowy, ale jeśli komuś by na tym zależało, zawsze może podobnie jak w języku Zig, udostępnić bezpośrednio adres pamięci do zapisu.
Rozwiązanie tutaj przedstawione jest jednak preferowane w większości wypadków, ponieważ programista nie musi się zastanawiać nad zarządzaniem pamięcią udostępnianą przeglądarce.
Po konwersji tablicy na typ \emph{Vec} używamy na niej funkcji \emph{sort\_by}, która jak można się domyśleć sortuję tablicę.

\subsection{Kompilacja}
Cały projekt kompilujemy korzystając z programu \emph{wasm-pack}.

\begin{minted}{text}
    $ wasm-pack build
\end{minted}

Kompilator, podobnie jak w przypadku AssemblyScript, oprócz utworzenia samego modułu WebAssembly, generuje również pomocnicze funkcje JavaScript oraz pliki typów TypeScript.
Generowane są również funkcje okalające, które alokują pamięć dla tablicy i przekazują ją pod spodem do właściwej funkcji.

\section{Porównanie języków}
Każdy z przedstawionych języków różnił się od pozostałych pod wieloma względami.
Bezpośrednie stwierdzenie, który z nich jest lepszy lub gorszy nie jest do końca możliwe.
Można natomiast porównać jak zachowywały się w konkretnych kategoriach i na tej podstawie stwierdzić, który z nich będzie rozsądnym wyborem dla większości osób.

\subsection{Instalacja}
Pod względem instalacji najwygodniejszy zdecydowanie był język Zig.
Instalacja sprowadzała się do pobrania i wypakowania archiwum, po czym można było rozpocząć tworzenie projektu.
AssemblyScript oraz Rust były trochę cięższe w instalacji, ale nie były one też specjalnie trudne.
Instalacja trwała po prostu dłużej.
Należy też zaznaczyć, że projekty tworzone w AssemblyScript oraz Rust, oprócz kompilacji do modułu WebAssembly, generowały też przydatne pliki JavaScript oraz TypeScript.
Zig na dzień dzisiejszy nie posiada bibliotek, które umożliwiałyby taką funkcjonalność.

\subsection{Implementacja prostych funkcji}
Kwestia składni i prostoty pisania w danym języku jest bardzo subiektywna, ponieważ w zależności od umiejętności i doświadczenia, każda osoba może mieć inne odczucia.
Najbardziej wyróżniającym się problemem były trudności w przekazywaniu dużych tablic do funkcji napisanej w języku Zig.
Zarówno Rust jak i AssemblyScript, dzięki generowaniu pomocniczych modułów JavaScript odciążają programistę z konieczności implementacji ich samemu.
Bardzo ważną kwestią jest też to, że Zig nie posiada żadnego wsparcia dla integracji z aplikacjami internetowymi.
Rust i AssemblyScript generując wspominane wcześniej pomocnicze moduły, bardzo upraszczają integrację modułu WebAssembly z resztą kodu pisanego w JavaScript.

\subsection{Wydajność}
Jednym z najważniejszych zagadnień w kontekście minimalizacji opóźnień aplikacji jest wydajność programów napisanych w danym języku.
W celu dokonania porównania, utworzono prostą aplikacje internetową.
Ładuje ona stworzone wcześniej moduły WebAssembly i wypisuje czas wywołania konkretnych funkcji dla różnych parametrów.
Warto też wspomnieć, że wyniki zależą od użytego sprzętu oraz przeglądarki.
Wszystkie aplikacje uruchamiane były na przeglądarce Google Chrome\footnote{\url{https://www.google.com/chrome/}} oraz Mozilla Firefox\footnote{\url{https://www.mozilla.org/firefox/}}.

Konfiguracja sprzętowa komputera testowego przedstawia się następująco:
\begin{itemize}
    \item Procesor \emph{ADM Ryzen 5 5600} -- 6 rdzeni / 12 wątków / 4,4 GHz
    \item Karta graficzna \emph{GeForce GTX 1080}
    \item Pamięć RAM 16GB DDR4
    \item System operacyjny \emph{Windows 10}
\end{itemize}

\begin{figure}[ht]
    \centering
    \import{plots}{sort6_chrome.pgf}
    \caption{Czas sortowania miliona liczb dla przeglądarki Google Chrome}
    \label{fig:sort6_chrome}

    \import{plots}{sort6_firefox.pgf}
    \caption{Czas sortowania miliona liczb dla przeglądarki Mozilla Firefox}
    \label{fig:sort6_firefox}
\end{figure}

Analizę wydajności rozpoczęto od funkcji sortującej milion liczb.
Jak można zauważyć na wykresie \ref{fig:sort6_chrome}, wszystkie moduły WebAssembly poradziły sobie o cały rząd złożoności lepiej niż JavaScript.
Rust osiągnął najlepszy wynik, ale Zig i AssemblyScript bardzo od niego nie odstawały.
Wykres \ref{fig:sort6_firefox} dla przeglądarki Firefox przedstawia podobną historię, z tą różnicą, że JavaScript osiągnęło dużo lepszy wynik niż na przeglądarce konkurencji.
Zig i Rust poradziły sobie najlepiej, a AssemblyScript osiągnęło wynik mniej więcej pomiędzy nimi a JavaScript.

\begin{figure}[ht]
    \centering
    \import{plots}{fib40_chrome.pgf}
    \caption{Czas wykonania \emph{fib(40)} dla przeglądarki Google Chrome}
    \label{fig:fib40_chrome}

    \import{plots}{fib40_firefox.pgf}
    \caption{Czas wykonania \emph{fib(40)} dla przeglądarki Mozilla Firefox}
    \label{fig:fib40_firefox}
\end{figure}

Dla funkcji obliczającej ciąg Fibonacciego, w przypadku przeglądarki Firefox odnotowano podobne zależności jak w poprzednim teście.
Na wykresie \ref{fig:fib40_firefox} można zauważyć, że najgorszy wynik uzyskała zwykła funkcja JavaScript.
Rust i Zig odnotowują najlepsze wyniki, natomiast AssemblyScript jest od nich trochę wolniejsze.
W przeglądarce Chrome natomiast sytuacja przedstawia się trochę inaczej.
Na wykresie \ref{fig:fib40_chrome} można zauważyć, że najgorszy wynik uzyskało AssemblyScript.
Rust jest tylko trochę szybszy od JavaScript, a Zig jest prawie dwukrotnie szybszy niż Rust.

\section{Wnioski}
Biorąc pod uwagę, że dla tematu tej pracy wydajność ma największe znaczenie, to AssemblyScript nie do końca jest w stanie konkurować.
Jakikolwiek wynik gorszy niż JavaScript świadczy o tym, że może kompilatorowi brakować niektórych optymalizacji.
Być może w przyszłości ten język będzie się świetnie nadawał do pisania wydajnych modułów WebAssembly.
Na ten moment jednak dla interaktywnych aplikacji webowych może być to niewystarczające.
Rust oraz Zig w kwestii wydajności są bardzo zbliżone.
Oba te języki korzystają bowiem z LLVM -- oznacza to, że w większości przypadków wygenerowany przez nich kod wynikowy będzie podobny.
Poza samą wydajnością jednak Rust jest lepszy na prawie każdym polu.
Integracja z aplikacjami webowymi jest dużo prostsza -- generowanie pomocniczego kodu potrafi zaoszczędzić mnóstwo czasu.
Do tego dokumentacja jest o wiele lepsza.
Pisaniu programów w Rust dla WebAssembly poświęcona jest cała książka, natomiast dla języka Zig ciężko znaleźć jakiekolwiek materiały w Internecie.
Rust posiada również bardzo bogaty ekosystem bibliotek, coś czego na ten moment językowi Zig brakuje.
Podsumowując, rekomendowanym wyborem języka programowania modułów WebAssembly dla interaktywnych aplikacji webowych jest zdecydowanie Rust.
Posiada wszystko czego można od takiego języka oczekiwać -- wydajność, dojrzałość i dużą ilość materiałów do nauki.

\chapter{Użytkowanie i wydajność Rust}

\section{Sumowanie macierzy}

\subsection{JavaScript}

\subsection{Rust}

\subsection{Rust z wykorzystaniem SIMD}

\section{Symulacja N ciał}

\subsection{JavaScript}

\subsection{Rust}

\section{Wnioski}

\chapter{Interaktywna aplikacja webowa z użyciem WebAssembly}

\section{Przykładowa aplikacja}

\section{Porównanie wydajności}

\section{Aplikacja natywna}

\section{WebRTC vs WebSocket}

\chapter{Podsumowanie}

\backmatter

\cleardoublepage
\renewcommand\listoflistingscaption{Spis listingów}
\listoflistings

\cleardoublepage
\listoffigures

\cleardoublepage
\printbibliography

\end{document}
