\documentclass[language=polish,type=master]{aghmodern}

\titleEN{Minimizing interaction delay in collaborative web applications}
\titlePL{Minimalizacja opóźnienia w interakcji użytkowników korzystających z aplikacji webowych}
\author{Piotr Szczygieł}
\faculty{Wydział Informatyki, Elektroniki i Telekomunikacji}
\department{Instytut Informatyki}
\supervisor{dr inż. Łukasz Czekierda}
\degreeprogramme{Informatyka}
\degreetype{Stacjonarne}
\date{2022}
\dedication{Test}

\usepackage[backend=biber,doi=true,url=false]{biblatex}
\addbibresource{bibliography.bib}

\usepackage[skip=2pt]{caption}

\setminted{autogobble,breaklines,frame=single,fontsize=\footnotesize}
\definecolor{number}{RGB}{102, 102, 102}
\definecolor{type}{RGB}{176, 0, 64}

\begin{document}

\frontmatter
\maketitle

\setcounter{tocdepth}{1}
\tableofcontents

\mainmatter

\onehalfspacing

\chapter{Wstęp}

\section{Cel}
Celem pracy jest stworzenie zbioru rekomendacji dla programistów tworzących interaktywne aplikacje webowe.
Rekomendacje będą dotyczyć dwóch kategorii tworzenia aplikacji.
Pierwszą z nich jest kwestia używania WebAssembly w nowych i istniejących aplikacjach.
Przedstawi ona przypadki, w których WebAssembly nie pomoże wydajności aplikacji.
Pokaże również te, gdzie użycie WebAssembly znacząco poprawi wydajność i responsywność danej strony.
Dotyczyć będzie ona również wyboru języka programowania kompilowanego do WebAssembly.
Programista tworzący aplikację z użyciem WebAssembly, będzie musiał zdecydować się na język programowania, w którym będzie pracować.
Różnią się one między sobą wygodą użytkowania oraz wydajnością kodu wynikowego generowanego przez ich kompilatory, więc jest to również ważna decyzja.
Druga rekomendacja to wybór technologii komunikacji sieciowej.
Przedstawi ona wyniki testów opóźnień pomiędzy WebSocket, a WebRTC.
Oprócz tego wyjaśnione zostaną różnice w wygodzie tworzenia aplikacji z użyciem danej technologii.
Finalnie więc czytelnik będzie miał pogląd na technologie używane w procesie tworzenia wydajnych i responsywnych aplikacji webowych.

\section{Motywacja}
Większość ludzi posiadających dostęp do internetu każdego dnia korzysta z różnego rodzaju stron internetowych.
W kieszeni posiadamy komputery z procesorami wielokrotnie razy szybszymi niż komputery personalne jeszcze nie tak dawno temu.
Pomimo tego niektóre strony internetowe potrafią ładować się po kilkanaście sekund, a przy próbie interakcji z nimi zachowywać się nieresponsywnie.
Wiele osób jest poirytowanych takim stanem rzeczy i wspomina czasy dużo wolniejszych komputerów, na których aplikacje mimo tego ładowały się szybko i nie zacinały się.
Stan ten spowodowany jest w głównej mierze pewnego rodzaju chaosem panującym wśród twórców stron internetowych.
Poradniki do tworzenia nawet najprostszych aplikacji zawierają kod zaciągający tysiące bibliotek niepotrzebnie spowalniających ich działanie.
Nowoczesne technologie takie jak WebAssembly kuszą wielu programistów rozwiązaniem tych problemów.
Jednak na tym stadium rozwoju wiele programistów nadal nie wie czy jest to coś przyszłościowego i wartego wdrażania do swoich aplikacji.
Aby ułatwić im dokonanie tego wyboru, w tej pracy skupiono się na pokazaniu z jakich technologii skorzystać, aby przyspieszyć działanie interaktywnych aplikacji webowych.
W tej pracy nie będą poruszane takie kwestie jak prędkość ładowania się strony internetowej.
Przedstawione aplikację będą wykonywały obliczenia lokalnie w przeglądarce i to głównie prędkość działania tej części programu będzie badana.

\section{Metodologia}
Prace rozpoczęto od zapoznania się z językami kompilowanymi do WebAssembly.
Po wybraniu trzech interesujących języków utworzono z ich wykorzystaniem prosty benchmark.
Został on użyty do badań nad wydajnością każdego z języków, a proces tworzenia aplikacji dostarczył informacji o wygodzie pisania w danym języku.
Po wybraniu jednego z języków utworzono inne aplikacje webowe, które dostarczyły więcej informacji o danej technologii.
Pozwalały one zbadać wydajność aplikacji napisanej w tym języku w porównaniu z aplikacją napisaną w JavaScript.
Na koniec zaprojektowano aplikację wpisującą się w nurt Tactile Internet.
Utworzono ją jednocześnie jako aplikacje webową JavaScript, WebAssembly oraz aplikację natywną.
Do tego dołączono również badania nad WebSocket oraz WebRTC.
Technologie te mogłyby służyć przykładowo jako kanał komunikacji w tej aplikacji.
Na podstawie otrzymanych wyników wysnuto wnioski oraz utworzono zestaw rekomendacji dla przyszłych programistów interaktywnych aplikacji webowych.


\section{Zawartość pracy}
Dalsza część pracy została rozdzielona na następujące części:

\begin{itemize}
    \item Rozdział 2 -- zawiera przedstawienie aktualnego stanu wiedzy
    \item Rozdział 3 -- przedstawia porównanie języków kompilowanych do WebAssembly
    \item Rozdział 4 -- bardziej szczegółowo sprawdza jeden z wybranych języków
    \item Rozdział 5 -- prezentuje przykładową aplikację webową
\end{itemize}

\chapter{Stan wiedzy}
W tym rozdziale przedstawione zostaną badane technologie oraz stan wiedzy z nimi związany.

\section{Wydajność WebAssembly}
WebAssembly (w skrócie WebAssembly) jest to binarny format instrukcji dla maszyny wirtualnej opartej na stosie.
Został stworzony jako przenośny cel kompilacji dla języków programowania.
Umożliwia tworzenie aplikacji webowych zarówno po stronie klienta jak i serwera.

Maszyna WebAssembly została przystosowana, aby wczytywać programy szybko, jednocześnie zajmując nie więcej pamięci niż jest to konieczne.
Celuje w osiągnięcie prędkości zbliżonej do natywnych aplikacji, korzystając z powszechnych możliwości sprzętowych dostępnych na różnych platformach.
Określa pewnego rodzaju piaskownicę\footnotemark{}, czyli bezpieczne pod względem pamięci oraz dostępu z zewnątrz środowisko wykonywalne.
\footnotetext{Piaskownica (ang. sandbox) -- mechanizm izolacji uruchamianych programów służący poprawie bezpieczeństwa.}

WebAssembly może być współcześnie stosowany jako dopełnienie JavaScript w tworzeniu aplikacji webowych.
Stopień tego dopełnienia może być różny, ale praca skupi się głównie na zastępowaniu fragmentów programu wykonujących dużą ilość obliczeń.
Przedstawione poniżej pracę poruszają kwestie porównania wydajności WebAssembly z resztą dostępnych rozwiązań.

W pracy \cite{wasm_blazor} \emph{Dawid Suryś}, \emph{Piotr Szłapa} oraz \emph{Maria Skublewska-Paszkowska} prowadzą badania nad wydajnością WebAssembly oraz JavaScript.
Dochodzą do wniosków, że WebAssembly może być szybszy od JavaScript w przypadku aplikacji zawierających dużą ilość obliczeń oraz operacji na zbiorach danych.
Mimo tworzenia aplikacji WebAssembly nadal jesteśmy zmuszeni do korzystania z JavaScript do wywoływania zapytań sieciowych czy operacji na DOM.
Powoduje to, że takie operacje są wolniejsze w WebAssembly niż w samym JavaScript przez dodatkowy narzut.
Przedstawiony test frameworka Blazor\footnotemark{} pokazał, że jest on wolniejszy niż istniejące popularne frameworki napisane w JavaScript.
\footnotetext{Blazor -- frontend w C\# wykorzystujący WebAssembly (\url{https://blazor.net/})}
Pokazał jednak, że WebAssembly jest na tyle dojrzały, aby stworzyć w nim kompletny i działający projekt.

Praca \cite{wasm_speedyjs} \emph{Micha Reiser} oraz \emph{Luc Bl\"{a}ser} przedstawia projekt \emph{Speedy.js}, który kompiluje wybrane funkcję z języka TypeScript\footnotemark{} do WebAssembly.
\footnotetext{TypeScript -- statycznie typowany nadzbiór JavaScript (\url{https://www.typescriptlang.org/})}
Generuje on również automatycznie kod pozwalający na łatwą integrację z resztą kodu napisanego w TypeScript.
W niektórych przypadkach osiągnięto nawet czterokrotne przyspieszenie dla funkcji skompilowanych do WebAssembly.
Projekt proponuje ciekawą strategie stopniowej transformacji kodu obliczeniowo intensywnego do WebAssembly.

\emph{Abhinav Jangda} i inni w swojej pracy \cite{wasm_native} porównują wydajność WebAssembly z natywnymi aplikacjami.
Wykorzystując \emph{BROWSIX-WASM}\footnotemark{} porównano wydajność programów skompilowanych do aplikacji natywnych oraz WebAssembly.
\footnotetext{BROWSIX -- projekt umożliwiający uruchamianie niezmodyfikowanych plików wykonywalnych systemu Linux w przeglądarce (\url{https://browsix.org/})}
Aplikacje WebAssembly były średnio wolniejsze od natywnych aplikacji o 1.55x dla przeglądarki Chrome i 1.45x dla Firefox.
Główny powód dla którego WebAssembly jest wolniejsze od natywnej aplikacji to gorsza optymalizacja kodu maszynowego.
Spowodowane jest to ograniczeniami wynikającymi ze specyfikacji WebAssembly (np. stack overflow checks, indirect call checks, reserved registers).
Ograniczenia te nie muszą być zawarte w aplikacji natywnej.

Artykuł \cite{wasm_js_bench} napisany przez \emph{David Herrera} i innych zawiera zbiór benchmarków porównujących WebAssembly oraz JavaScript w różnych konfiguracjach.
Dla maszyny z systemem Windows, WebAssembly był około 70\% szybszy dla przeglądarki Chrome, 60\% szybszy dla Firefox i 163\% szybszy dla przeglądarki Edge.
Z tych trzech przeglądarek najlepsze wyniki odniósł Firefox.

\emph{Weihang Wang} w swoim artykule \cite{wasm_js_bench2} porównuje WebAssembly i JavaScript dla czasu wykonania i zużycia pamięci różnych programów.
Zauważa, że WebAssembly zużywa dużo więcej pamięci niż JavaScript.
Mimo tego WebAssembly był dużo szybszy od JavaScript dla bardzo małych rozmiarów danych (35.3x średnie przyspieszenie) oraz małych danych (7.67x średnie przyspieszenie).
Natomiast dla większych rozmiarów danych, dzięki \emph{JIT}\footnotemark{}, JavaScript doganiał WebAssembly, a nawet zdarzały się przypadki gdzie WebAssembly był wolniejszy od JavaScript.
\footnotetext{Kompilator JIT -- kompiluje kod w trakcie wykonywania programu, w przeciwieństwie do zwykłych kompilatorów, które robią to przed jego uruchomieniem}
Otrzymane przez niego wyniki pokazują, że optymalizacja \emph{JIT} w Chrome znacząco poprawia wyniki JavaScript, nie mając wpływu na WebAssembly.

\subsection{Wnioski}
WebAssembly jest obiecującą technologią.
Dla wielu przypadków osiągał dużo lepsze wyniki, jeśli chodzi o obliczenia w przeglądarce.
Mimo tego wspomniane prace głównie skupiały się na samej wydajności, a niewiele było poruszonych tematów tworzenia aplikacji.
Wiele benchmarków były to programy napisane w C przeportowane\footnotemark{} do WebAssembly.
\footnotetext{Portowanie -- proces przenoszenia wersji programu komputerowego na inną platformę sprzętową lub programistyczną}
W tej pracy poruszony zostanie natomiast temat tworzenia nowych aplikacji oraz wybór języka kompilowanego do WebAssembly, który się do tego najbardziej aktualnie nadaje.

\section{WebRTC vs WebSocket}
WebRTC to technologia umożliwiająca aplikacjom webowym i stronom internetowym przechwytywać oraz opcjonalnie strumieniować media audio-wizualne.
Pozwala również na wymianę różnorodnych danych pomiędzy przeglądarkami bez konieczności posiadania serwera pośredniczącego.
Pod spodem korzysta z protokołów UDP, TCP oraz SCTP w zależności od ustawień firewall użytkowników oraz rodzaju przesyłanych danych.

WebSocket natomiast to technologia umożliwiająca otwarcie interaktywnej sesji komunikacji pomiędzy przeglądarką a serwerem.
Zapewnia dwukierunkowy kanał wymiany danych poprzez pojedyncze połączenie TCP.
Przedstawione poniżej prace skupiają się na porównaniu tych dwóch technologii w różnych kontekstach.

\emph{G{\"u}nay Mert Karadogan} w swojej pracy \cite{websocket_webrtc_iot} bada WebRTC oraz WebSocket pod względem użycia ich w IoT\footnotemark{}.
\footnotetext{Internet of Things -- sieć fizycznych obiektów wyposażonych w czujniki i oprogramowanie umożliwiające wymianę danych z innymi urządzeniami za pośrednictwem Internetu}
Wnioskuje on, że zarówno WebSocket jak i WebRTC może zostać użyte do łączenia urządzeń IoT z Internetem.

\emph{Tomasz Karla} i \emph{Jarosław Tarnawski} w pracy \cite{websocket_webrtc_realtime} porównują opóźnienie technologii WebRTC oraz WebSocket w różnych scenariuszach.
Testowane były przykładowo sieci lokalne, GSM oraz WiFi. Technologia WebRTC zanotowała minimalnie mniejsze opóźnienia.
Umożliwił on również komunikacje aplikacji w obrębie sieci lokalnej\footnotemark{}, mimo postawienia strony na publicznym serwerze.
\footnotetext{WebRTC potrafi połączyć się między dwoma przeglądarkami bezpośrednio, jeśli ustawienia Firewall użytkowników na to pozwalają}
Autorzy wnioskują, że obie technologie jak najbardziej nadają się do tworzenia aplikacji sieciowej.

Praca \cite{websocket_webrtc_streamr} \emph{Santeri Juslenius} analizowała zachowanie technologii WebRTC oraz WebSocket w sieci \emph{Streamr}, która jest zdecentralizowanym systemem \emph{publish-subscribe}\footnotemark{}.
\footnotetext{Jest to system komunikacji, w którym wysyłane wiadomości mają przypisane pewne kategorie, które odbiorcy mogą subskrybować w celu ich otrzymywania}
Na podstawie wyników badań autorzy doszli do wniosku, że WebSocket odnosi lepsze rezultaty pod względem opóźnień.
Jednak dla tej konkretnej topologii WebRTC był bardziej użyteczny ze względu na lepsze wyniki dla małych pakietów oraz możliwości połączeń P2P.

\subsection{Wnioski}
Wszystkie prace zgodnie uznają, że obie technologie nadają się do tworzenia aplikacji sieciowych.
Niektóre mówią o niższych opóźnieniach dla WebRTC, a inne dla WebSocket.
W tej pracy porównamy wykorzystanie tych technologii w interaktywnych aplikacjach webowych.

\chapter{Języki kompilowane do WebAssembly}
WebAssembly jest binarnym formatem, interpretowanym przez wirtualną maszynę uruchamianą w przeglądarce lub jako niezależną aplikację.
Nie jest on więc językiem programowania samym w sobie.
Może on natomiast być celem kompilacji dla innych języków.
Wybór takiego języka może okazać się równie ważny jak podjęcie decyzji o tym czy w ogóle korzystać z WebAssembly.
Aktualnie dużo języków ma możliwość ustawienia WebAssembly jako platformę wynikową kompilacji.
W tej pracy jednak skupiono się na trzech: Zig, AssemblyScript oraz Rust.
Pierwszym językiem, któremu zostanie poświęcona uwaga w tej pracy jest Zig.
Jest to młody, szybko rozwijający się język, którego celem jest zastąpienie współczesnych użyć języka C.
AssemblyScript został wybrany jako język bardzo zbliżony składnią i użyciem do popularnego TypeScript.
Dzięki niemu programiści stron internetowych mogliby bez dużej ilości nauki tworzyć moduły WebAssembly.
Rust został wybrany ze względu na największą popularność wśród programistów WebAssembly.
W tym rozdziale przedstawione będzie porównanie tych języków zarówno pod względem wydajności kodu wynikowego jak i ogólnego procesu tworzenia aplikacji.
Pominięto takie języki jak C oraz C++ ze względu na to, że tak samo jak Rust i Zig korzystają z LLVM\footnotemark{} do generowania kodu wynikowego.
\footnotetext{LLVM -- backend dla kompilatorów z którego korzystają różne frontendy dla takich języków jak C, C++, Rust, Zig, Swift i wiele innych (\url{https://llvm.org/})}
Z tego powodu różnice w wydajności kodu wynikowego będą marginalne i będą wywodzić się głównie ze stylu pisania kodu w danym języku.
Mimo, że pod spodem korzystają z tego samego kompilatora, to programy napisane w języku C często są szybsze od ich odpowiedników w C++.
Spowodowane jest to tym, że programiści C pozbawieni takich funkcjonalności języka jak RAII\footnotemark{}, zmuszeni są do bardziej szczegółowej kontroli alokacji pamięci i sposobu ułożenia w niej danych.
\footnotetext{Resource acquisition is initialization -- wzorzec projektowy łączący konstrukcję i destrukcję obiektu z alokacją i zwalnianiem zasobów z których korzysta}
Z tego powodu C i C++ niekoniecznie będą wydajniejsze od Rust, a współcześnie programiści starają się odchodzić od korzystania z tych języków w nowych projektach na rzecz nowocześniejszych i wygodniejszych technologii.
Zaprezentowane zostanie utworzenie dwóch prostych funkcji w każdym z języków -- rekurencyjnego obliczania n-tej liczby ciągu Fibonacciego oraz sortowania tablicy liczb.
Proces ich implementacji będzie służył zaobserwowaniu jak skomplikowane jest utworzenie modułu WebAssembly w każdym z wybranych języków.
Przedstawiona będzie rekurencyjna wersja obliczania n-tej liczby ciągu Fibonacciego zamiast iteracyjnej, ponieważ jest dużo wolniejsza i szybko zapełnia stos, dzięki czemu łatwiej pokazuje różnice w wydajności między językami.
Te dwie testowane funkcje nie umożliwią dokładnego porównania wydajności języków, ale zapewnią nam pewien powierzchowny wgląd w ich wydajność, który wystarczy do wstępnej oceny danego języka.

\section{Zig}
Posiłkując się definicją ze strony głównej projektu\footnotemark{}, Zig to język programowania ogólnego przeznaczenia i zestaw narzędzi do utrzymywania solidnego i optymalnego oprogramowania wielokrotnego użytku.
\footnotetext{\url{https://ziglang.org/}}
Jest nowoczesnym zastępcą języka C, czyli niskopoziomowym kompilowanym językiem, bez ukrytych alokacji pamięci, automatycznej dealokacji i tym podobnych rozwiązań.
Jednocześnie próbuje naprawić główne problemy swojego poprzednika przykładowo wychwytując dużo problemów związanych z bezpieczeństwem pamięci już w trakcie kompilacji.

\subsection{Instalacja}
Proces instalacji potrzebnych narzędzi jest bardzo prosty i zajmuje dosłownie minutę.
Wystarczy pobrać archiwum ze strony, wypakować i ewentualnie dodać folder do zmiennej środowiskowej \emph{PATH}, aby można było kompilować bez podawania pełnej ścieżki do kompilatora.
Zamiast pobierać manualnie, można też skorzystać z menadżera paczek dla używanego systemu operacyjnego.
Pobrany zestaw narzędzi zawiera wszystko co potrzebne do utworzenia modułu WebAssembly.

\subsection{Tworzenie funkcji \emph{fib}}
Tworzenie aplikacji można rozpocząć od napisania funkcji rekurencyjnie liczącej n-tą liczbę w ciągu Fibonacciego.

\begin{listing}[H]
    \begin{minted}{zig}
        export fn fib(n: u64) u64 {
            if (n == 1) return 1;
            if (n == 2) return 1;
            return fib(n - 1) + fib(n - 2);
        }
    \end{minted}
    \caption{Funkcja \emph{fib} w języku Zig}
\end{listing}

Jak widać składnia jest bardzo zbliżona do języków z rodziny C.
Słowo kluczowe \emph{export} umożliwia wywołanie danej funkcji z poziomu JavaScript.

\subsection{Tworzenie funkcji \emph{sort}}
Kolejnym krokiem jest utworzenie funkcji, która otrzymuje tablicę z zewnątrz, a następnie ją sortuje.
Pojawia się tutaj jednak pierwszy problem -- zarządzanie pamięcią.
Nie można mianowicie przekazać tablicy bezpośrednio z poziomu kodu napisanego w JavaScript do modułu WebAssembly.
Program napisany w Zig ma jedynie dostęp do swojej pamięci, która znajduję się w piaskownicy.
Należy więc udostępnić tę pamięć użytkownikowi, aby mógł przez nią przekazać nam tablicę do posortowania.

% Minted doesn't detect Zig 10_000_000 number correctly and it breaks syntax highlighting
\begin{listing}[H]
    \begin{minted}[escapeinside=||]{zig}
        const std = @import("std");
        const allocator = @import("std").heap.page_allocator;

        var array: []f64 = undefined;

        export fn initialize_array() *f64 {
            array = allocator.alloc(f64, |\textcolor{number}{10\_000\_000}|) catch unreachable;
            return &array[0];
        }

        export fn sort(size: usize) void {
            std.sort.sort(f64, array[0..size], {}, comptime std.sort.asc(f64));
        }
    \end{minted}
    \caption{Funkcja \emph{sort} i jej kod pomocniczy w języku Zig}
\end{listing}

Funkcja \emph{initialize\_array} alokuje najpierw 10MB pamięci, a następnie zwraca wskaźnik na początek zaalokowanej tablicy.
Dzięki temu użytkownik będzie mógł ją wypełnić swoimi danymi, a następnie za pomocą funkcji \emph{sort} posortować N pierwszych liczb.
Nie jest to najwygodniejszy sposób pisania kodu operującego na danych przekazywanych z poziomu strony internetowej.
Zostanie przedstawione później jak w prostszy sposób inne języki radzą sobie z tym problemem.

\subsection{Kompilacja}
Można teraz skompilować plik, który nazwany został \emph{main.zig} i utworzyć moduł WebAssembly \emph{zig.wasm} następującym poleceniem:

\begin{minted}{console}
    $ zig build-lib main.zig -target wasm32-freestanding -dynamic -O ReleaseFast -femit-bin=zig.wasm
\end{minted}

Ustawiono poziom optymalizacji na \emph{ReleaseFast}, aby uzyskać jak najlepszą wydajność modułu.
Język Zig oprócz kompilacji z poziomu linii poleceń umożliwia również tworzenie bardziej skomplikowanych programów budujących.
Mogą być one napisane również w języku Zig, zamiast w jakimś innym, nie związanym z aplikacją języku opisującym proces budowania.
Dzięki temu nie trzeba uczyć się dodatkowych narzędzi takich jak CMake, Make czy wiele innych.
Temat ten jednak wychodzi poza zakres tej pracy.

\section{AssemblyScript}
AssemblyScript został zaprojektowany specjalnie dla WebAssembly.
Dzięki temu nie musimy korzystać z dodatkowych bibliotek, aby umożliwić jego kompilację do WebAssembly.
Korzysta ze składni bardzo zbliżonej do języka TypeScript, dzięki czemu programiści stron internetowych nie muszą poświęcać dużo czasu na jego naukę.

\subsection{Instalacja}
AssemblyScript w prosty sposób integruje się z istniejącym ekosystemem stron internetowych.
Zainstalować go można korzystając z menadżera paczek \emph{npm}.
Cały proces inicjalizacji nowego projektu jest szybki, prosty i dokładnie opisany w oficjalnym wstępie do języka\footnotemark{}.
\footnotetext{\url{https://www.assemblyscript.org/getting-started.html}}

\subsection{Tworzenie funkcji \emph{fib}}
Pisanie kodu rozpoczęto w wygenerowanym pliku \emph{index.ts} od funkcji \emph{fib}.

% Second u64 is not highlighted for some reason
\begin{listing}[H]
    \begin{minted}[escapeinside=||]{typescript}
        export function fib(n: u64): |\textcolor{type}{u64}| {
            if (n == 1) return 1;
            if (n == 2) return 1;
            return fib(n - 1) + fib(n - 2);
        }
    \end{minted}
    \caption{Funkcja \emph{fib} w języku AssemblyScript}
\end{listing}

Kod jest praktycznie taki sam jaki można by napisać w języku TypeScript.
Główną różnicą jest użycie typu \emph{u64}, ponieważ WebAssembly wymaga specyfikacji konkretnego typu liczby obsługiwanego przez maszynę wirtualną.

\subsection{Tworzenie funkcji \emph{sort}}

Funkcje sort można w tym języku napisać dużo szybciej niż w języku Zig.

\begin{listing}[H]
    \begin{minted}{typescript}
        export function sort(array: Array<f64>): void {
            array.sort();
        }
    \end{minted}
    \caption{Funkcja \emph{sort} w języku AssemblyScript}
\end{listing}

Jak można zauważyć, wystarczy że ustawimy typ zmiennej wejściowej jako \emph{Array<f64>}, aby funkcja przyjmowała tablicę liczb zmiennoprzecinkowych.
W przeciwieństwie do języka Zig, nie jest konieczne manualnie tworzenie bufora, do którego przekażemy tablice z zewnątrz.
AssemblyScript w trakcie kompilacji automatycznie generuje kod, dzięki któremu nie musimy się tym przejmować.
Tworzona jest funkcja okalająca (ang. wrapper function), która alokuje pamięć dla naszej tablicy i przekazuje ją do właściwej funkcji jako wskaźnik na tę pamięć.

\subsection{Kompilacja}
Skompilować projekt możemy za pomocą narzędzia \emph{npm}.

\begin{minted}{console}
    $ npm run build
\end{minted}

Podczas inicjalizacji projektu wygenerowały się pliki konfiguracyjne, które powodują, że to polecenie kompiluje program do modułu WebAssembly.
Co ważne w przypadku tego języku, z racji na ścisłą integrację z resztą ekosystemu tworzenia stron internetowych, buduje to również jednocześnie pozostały kod strony.
Oznacza to, że nie potrzebujemy dodatkowego kroku kompilacji WebAssembly, a wszystko odbywa się z użyciem jednego systemu budującego.
Bardzo przydatną funkcją są również automatycznie generowane pliki typów TypeScript.

\begin{listing}[H]
    \begin{minted}{typescript}
        export declare function fib(n: bigint): bigint;
        export declare function sort(array: Array<number>): void;
    \end{minted}
    \caption{Fragment wygenerowanego pliku typów AssemblyScript}
\end{listing}

Dzięki nim otrzymywano podpowiedzi w środowisku programistycznym w trakcie odwoływania się do funkcji napisanych w AssemblyScript.

\section{Rust}
Rust, podobnie jak Zig jest językiem programowania ogólnego przeznaczenia.
Stworzony został z myślą o bezpieczeństwie, współbieżności i praktyczności.
Według corocznej ankiety serwisu Stack Overflow\footnotemark{}, Rust jest najbardziej lubianym językiem programowania od 2015 roku.
\footnotetext{\url{https://insights.stackoverflow.com/survey/}}

\subsection{Instalacja}
Rust można zainstalować korzystając z menadżera paczek systemu operacyjnego lub skorzystać z programu \emph{rustup}\footnotemark{}, który szybko przeprowadzi użytkownika przez kolejne kroki instalacji.
\footnotetext{\url{https://rustup.rs/}}
Instalacja w systemie Windows wymaga również zainstalowania Microsoft Visual Studio dla języka C++.
Po zainstalowaniu języka możemy przystąpić do tworzenia nowego projektu.
Książka \emph{Rust and WebAssembly}\footnotemark{} prezentuje krok po kroku ten proces.
\footnotetext{\url{https://rustwasm.github.io/}}
Jest on prosty i zrozumiały oraz przedstawia jak w prosty sposób zintegrować utworzone moduły ze stronami internetowymi.

\subsection{Tworzenie funkcji \emph{fib}}
Po przygotowaniu środowiska można rozpocząć edycję pliku \emph{lib.rs}.

\begin{listing}[H]
    \begin{minted}{rust}
        #[wasm_bindgen]
        pub fn fib(n: u64) -> u64 {
            match n {
                1 => 1,
                2 => 1,
                _ => fib(n - 1) + fib(n - 2)
            }
        }
    \end{minted}
    \caption{Funkcja \emph{fib} w języku Rust}
\end{listing}

Jak widać, poza specyficzną dyrektywą \emph{match}, kod powinien być zrozumiały dla większości programistów.
W języku Rust ostatnie wyrażenie w funkcji uznawane jest jako wartość zwracana, a dyrektywa \emph{match} działa podobnie jak \emph{switch} w językach z rodziny C.
Atrybut \emph{wasm\_bindgen} oznacza funkcje jako dostępną do wywołania z poziomu kodu JavaScript strony internetowej.
Jest to wymagane, dlatego że oprócz modułu WebAssembly, automatycznie generowany będzie również kod JavaScript inicjalizujący ten moduł oraz dodający funkcje pomocnicze.
Podobne rozwiązanie mogliśmy zauważyć w projekcie AssemblyScript, a brak jego jest odczuwalny tworząc projekt w języku Zig.

\subsection{Tworzenie funkcji \emph{sort}}
Przekazywanie tablicy do modułu WebAssembly można zrobić na różne sposoby.
Jeden z nich jest przedstawiony poniżej.

\begin{listing}[H]
    \begin{minted}{rust}
        #[wasm_bindgen]
        pub fn sort(js_array: &Float64Array) {
            let mut numbers: Vec<f64> = js_array.to_vec();
            numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());
        }
    \end{minted}
    \caption{Funkcja \emph{sort} w języku Rust}
\end{listing}

Przekazaną z poziomu JavaScript tablicę konwertujemy na natywny dla języka Rust typ \emph{Vec}, który określa dynamiczną tablicę.
Może to spowodować mały narzut czasowy, ale jeśli byłoby to konieczne, można podobnie jak w języku Zig, udostępnić bezpośrednio adres pamięci do zapisu.
Rozwiązanie tutaj przedstawione jest jednak preferowane w większości wypadków, ponieważ programista nie musi się zastanawiać nad zarządzaniem pamięcią udostępnianą przeglądarce.
Po konwersji tablicy na typ \emph{Vec} używamy na niej funkcji \emph{sort\_by}, która sortuję tablicę.

\subsection{Kompilacja}
Cały projekt kompilujemy korzystając z programu \emph{wasm-pack}.

\begin{minted}{console}
    $ wasm-pack build
\end{minted}

Kompilator, podobnie jak w przypadku AssemblyScript, oprócz utworzenia samego modułu WebAssembly, generuje również pomocnicze funkcje JavaScript oraz pliki typów TypeScript.
Generowane są również funkcje okalające, które alokują pamięć dla tablicy i przekazują ją pod spodem do właściwej funkcji.

\section{Porównanie języków}
Każdy z przedstawionych języków różnił się od pozostałych pod wieloma względami.
Bezpośrednie stwierdzenie, który z nich jest lepszy lub gorszy nie jest do końca możliwe.
Można natomiast porównać jak zachowywały się w konkretnych kategoriach i na tej podstawie stwierdzić, który z nich będzie rozsądnym wyborem dla większości osób.

\subsection{Instalacja}
Pod względem instalacji najwygodniejszy zdecydowanie był język Zig.
Instalacja sprowadzała się do pobrania i wypakowania archiwum, po czym można było rozpocząć tworzenie projektu.
AssemblyScript oraz Rust były trochę cięższe w instalacji, ale nie były one też specjalnie trudne.
Instalacja trwała po prostu dłużej.
Należy też zaznaczyć, że projekty tworzone w AssemblyScript oraz Rust, oprócz kompilacji do modułu WebAssembly, generowały też przydatne pliki JavaScript oraz TypeScript.
Zig na dzień dzisiejszy nie posiada bibliotek, które umożliwiałyby taką funkcjonalność.

\subsection{Implementacja prostych funkcji}
Kwestia składni i prostoty pisania w danym języku jest bardzo subiektywna, ponieważ w zależności od umiejętności i doświadczenia, każda osoba może mieć inne odczucia.
Najbardziej wyróżniającym się problemem były trudności w przekazywaniu dużych tablic do funkcji napisanej w języku Zig.
Zarówno Rust jak i AssemblyScript, dzięki generowaniu pomocniczych modułów JavaScript odciążają programistę z konieczności implementacji ich samemu.
Bardzo ważną kwestią jest też to, że Zig nie posiada żadnego wsparcia dla integracji z aplikacjami internetowymi.
Rust i AssemblyScript generując wspominane wcześniej pomocnicze moduły, bardzo upraszczają integrację modułu WebAssembly z resztą kodu pisanego w JavaScript.

\subsection{Wydajność}
Jednym z najważniejszych zagadnień w kontekście minimalizacji opóźnień aplikacji jest wydajność programów napisanych w danym języku.
W celu dokonania porównania, utworzono prostą aplikacje internetową.
Ładuje ona stworzone wcześniej moduły WebAssembly i wypisuje czas wywołania konkretnych funkcji dla różnych parametrów.
Warto też wspomnieć, że wyniki zależą od użytego sprzętu oraz przeglądarki.
Wszystkie aplikacje uruchamiane były na przeglądarce Google Chrome\footnote{\url{https://www.google.com/chrome/}} oraz Mozilla Firefox\footnote{\url{https://www.mozilla.org/firefox/}}.
Konfiguracja sprzętowa komputera testowego przedstawia się następująco:
\begin{itemize}
    \itemsep0em
    \item Procesor \emph{ADM Ryzen 5 5600} -- 6 rdzeni / 12 wątków / 4,4 GHz
    \item Karta graficzna \emph{GeForce GTX 1080}
    \item Pamięć RAM 16GB DDR4
    \item System operacyjny \emph{Windows 10}
\end{itemize}

Poniżej przedstawiono również kod w języku JavaScript do którego porównywane były inne wyniki.

\begin{listing}[H]
    \begin{minted}{javascript}
        function sort(array) {
            array.sort();
        }

        function fib(n) {
            if (n === 1) return 1;
            if (n === 2) return 1;
            return fib(n - 1) + fib(n - 2); 
        }
    \end{minted}
    \caption{Funkcje \emph{sort} oraz \emph{fib} zaimplementowany w języku JavaScript}
\end{listing}

Analizę wydajności rozpoczęto od funkcji sortującej milion liczb.
Jak można zauważyć na wykresie \ref{fig:sort6}, Rust i Zig osiągnęły najlepsze wyniki, AssemblyScript był od nich trochę wolniejszy.
Dla przeglądarki Chrome wszystkie moduły WebAssembly były o cały rząd złożoności szybsze niż JavaScript.
Dla przeglądarki Firefox natomiast Zig i Rust były około czterokrotnie szybsze, a AssemblyScript około dwukrotnie szybszy.

\begin{figure}[H]
    \centering
    \import{plots}{sort6.pgf}
    \caption{Czasy sortowania miliona liczb}
    \label{fig:sort6}
\end{figure}

Dla funkcji obliczającej ciąg Fibonacciego, w przypadku przeglądarki Firefox odnotowano podobne zależności jak w poprzednim teście.
Na wykresie \ref{fig:fib40} można zauważyć, że najgorszy wynik uzyskała zwykła funkcja JavaScript.
Rust i Zig odnotowują najlepsze wyniki, natomiast AssemblyScript jest od nich trochę wolniejsze.
W przeglądarce Chrome natomiast sytuacja przedstawia się trochę inaczej.
Na wykresie \ref{fig:fib40} można zauważyć, że najgorszy wynik uzyskało AssemblyScript.
Rust jest tylko trochę szybszy od JavaScript, a Zig jest prawie dwukrotnie szybszy niż Rust.

\begin{figure}[H]
    \centering
    \import{plots}{fib40.pgf}
    \caption{Czasy wykonania \emph{fib(40)}}
    \label{fig:fib40}
\end{figure}

\section{Wnioski}
Biorąc pod uwagę, że dla tematu tej pracy wydajność ma największe znaczenie, to AssemblyScript nie do końca jest w stanie konkurować z językami Rust i Zig.
Jakikolwiek wynik gorszy niż JavaScript świadczy o tym, że może kompilatorowi brakować niektórych optymalizacji.
Być może w przyszłości ten język będzie bardziej się nadawał do pisania wydajnych modułów WebAssembly.
Na ten moment jednak dla interaktywnych aplikacji webowych może być to niewystarczające.
Rust oraz Zig w kwestii wydajności są bardzo zbliżone.
Oba te języki korzystają bowiem z LLVM -- oznacza to, że w większości przypadków wygenerowany przez nich kod wynikowy będzie podobny.
Poza samą wydajnością jednak Rust jest lepszy na prawie każdym polu.
Integracja z aplikacjami webowymi jest dużo prostsza -- generowanie pomocniczego kodu potrafi zaoszczędzić mnóstwo czasu.
Do tego dokumentacja jest o wiele lepsza.
Pisaniu programów w Rust dla WebAssembly poświęcona jest cała książka, natomiast dla języka Zig ciężko znaleźć jakiekolwiek materiały w Internecie.
Rust posiada również bardzo bogaty ekosystem bibliotek, coś czego na ten moment językowi Zig brakuje.
Podsumowując, rekomendowanym wyborem języka programowania modułów WebAssembly dla interaktywnych aplikacji webowych jest zdecydowanie Rust.
Posiada wszystko czego można od takiego języka oczekiwać -- wydajność, dojrzałość i dużą ilość materiałów do nauki.

\chapter{Użytkowanie i wydajność Rust}
Na podstawie prostych testów w poprzednim rozdziale wybrano język Rust jako rekomendowany do tworzenia modułów WebAssembly.
W tym rozdziale zaprezentowany zostanie dokładniejszy wgląd w prostotę użytkowania oraz wydajność tego języka.

\section{Sumowanie macierzy}
Zagłębiając się w badania nad wydajnością modułów WebAssembly pisanych w języku Rust dla interaktywnych aplikacji webowych, należy zastanowić się gdzie taka aplikacja używa najwięcej czasu procesora.
Wykonywane lokalnie obliczenia prawdopodobnie będą odbywały się na danych otrzymanych z jakiegoś zewnętrznego serwera.
W tym przykładowym teście utworzone zostaną aplikacje wykonujące proste sumowanie dwóch macierzy.
Będzie to o tyle zbliżone do prawdziwego przypadku użycia, że macierze mogą opisywać np. strumień obrazów otrzymywany od zewnętrznego serwera, a sumowanie ich naśladować operacje wykonywane na tym obrazie.
Rozmiar sumowanych wektorów ustawiono na \emph{N = 1024}.

\subsection{JavaScript}
Test rozpoczęto od utworzenia funkcji sumującej macierze jednokolumnowe w języku JavaScript.

\begin{listing}[H]
    \begin{minted}{javascript}
        function add(a, b, c) {
            for (let i = 0; i < N; i++) {
                c[i] = a[i] + b[i];
            }
        }
    \end{minted}
    \caption{Funkcja \emph{add} w języku JavaScript}
\end{listing}

Do funkcji przekazujemy wektory \emph{a}, \emph{b} oraz \emph{c}.
Funkcja ta następnie do wektora \emph{c} zapisuję sumę wektorów \emph{a} oraz \emph{b}.

\subsection{Rust}
Taka sama funkcja została zaimplementowana w języku Rust.
Oprócz niej utworzone zostały pomocnicze funkcje umożliwiające kopiowanie i pobieranie macierzy z wewnętrznej pamięci WebAssembly.
Dzięki temu czas wywołania funkcji nie będzie zawierał narzutu związanego z kopiowaniem danych.

\begin{listing}[H]
    \begin{minted}{rust}
        pub fn add(&mut self) {
            for i in 0..N {
                self.c[i] = self.a[i] + self.b[i];
            }
        }
    \end{minted}
    \caption{Funkcja \emph{add} w języku Rust}
\end{listing}

\subsection{Rust z wykorzystaniem SIMD}
Tworzenie modułów WebAssembly umożliwia dostęp do operacji \emph{SIMD}\footnotemark{}.
\footnotetext{Single instruction, multiple data -- w kontekście architektury procesora, umożliwia jedną instrukcją modyfikację wielu danych jednocześnie}
Dzięki temu wykonując obliczenia na dużej ilości danych, wykorzystamy w pełni możliwości używanego procesora.

\begin{listing}[H]
    \begin{minted}{rust}
        pub fn add_simd(&mut self) {
            let simd_a = self.a.as_ptr() as *const f32x16;
            let simd_b = self.b.as_ptr() as *const f32x16;
            let simd_c = self.c.as_mut_ptr() as *mut f32x16;
    
            let chunks = (N / 16) as isize;

            for i in 0..chunks {
                unsafe {
                    *simd_c.offset(i) = *simd_a.offset(i) + *simd_b.offset(i);
                }
            }
        }
    \end{minted}
    \caption{Funkcja \emph{add} w języku Rust z użyciem SIMD}
\end{listing}

Funkcja ta jest bardziej skomplikowana od swoich poprzedników.
Działanie jej sprowadza się do sumowania w jednej iteracji szesnastu liczb jednocześnie, zamiast jednej.
Teoretycznie więc procesor musi wykonać szesnastokrotnie mniej operacji w celu uzyskania tego samego wyniku.
Nie oznacza to jednak, że kod będzie dużo szybszy, należy pamiętać o tym, że instrukcje SIMD zajmują więcej cykli procesora.
Sporą część czasu zajmuje też wczytanie danych do pamięci cache.
W niektórych przypadkach kompilator potrafi nawet sam przekształcić nasz kod tak, aby wykorzystywał instrukcje SIMD.
Koniecznie jest więc sprawdzenie czy faktycznie warto pisać kod w taki sposób, bo może kompilator robi to już sam.

\subsection{Wydajność}
Na wykresie czasu wykonania funkcji \ref{fig:matrix} można zauważyć, że każda kolejna funkcja radzi sobie lepiej od poprzedniej.
Dla obu testowanych przeglądarek wyniki wyszły podobne -- JavaScript poradził sobie najgorzej z czasem w okolicach jednej sekundy.
Wersja napisana w języku Rust była około dwa razy szybsza, a kiedy dodatkowo korzystała z SIMD, czas skrócił się o około 250 milisekund dla Chrome i 100 milisekund dla Firefox.

\begin{figure}[H]
    \centering
    \import{plots}{matrix.pgf}
    \caption{Czasy wykonania miliona iteracji funkcji obliczającej $\vec{c} = \vec{a} + \vec{b}$}
    \label{fig:matrix}
\end{figure}

\subsection{Wnioski}
Ten prosty test udowadnia, że Rust potrafi bardzo przyspieszyć operacje na dużej ilości danych.
Pokazuje też, że dzięki stosowaniu niskopoziomowego języka można uzyskać większą kontrolę nad instrukcjami wykonywanymi przez procesor, otrzymując jeszcze większe przyspieszenie.

\section{Symulacja N ciał}
Kolejnym testem będzie symulacja N ciał.
Polega ona na wyznaczeniu toru ruchów wszystkich ciał układu o danych masach, prędkościach i początkowych położeniach.
Opiera się ona o prawa ruchu i założenie, że ciała oddziałują ze sobą zgodnie z prawem grawitacji Newtona.
Oprócz samych obliczeń wykonywanych zarówno w JavaScript jak i Rust, aktualny stan układu wyświetlany jest w przeglądarce, jak przedstawiono na rysunku \ref{fig:nbody_screenshot}. 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{images/nbody.pdf}
    \caption{Wyświetlany stan symulacji w przeglądarce po kilku sekundach}
    \label{fig:nbody_screenshot}
\end{figure}

\subsection{JavaScript}
Symulacja została początkowo napisana w języku JavaScript, aby stanowić punkt odniesienia dla przyszłego kodu pisanego w języku Rust.
Zaimplementowano prosty algorytm, z zagnieżdżoną pętlą, która dla każdego ciała oblicza siły na nie działające, a następnie na tej podstawie zmienia jego położenie.

\begin{listing}[H]
    \begin{minted}{javascript}
        function tick(bodies) {
            for (let i = 1; i < bodies.length; i++) {
                bodies[i].ax = 0;
                bodies[i].ay = 0;

                for (let j = 0; j < bodies.length; j++) {
                    if (i === j) {
                        continue;
                    }

                    let dx = bodies[i].x - bodies[j].x;
                    let dy = bodies[i].y - bodies[j].y;
                    let r = Math.max(Math.sqrt(dx * dx + dy * dy), E);
                    let f = G * bodies[j].mass / (r * r);

                    bodies[i].ax -= f * (dx / r);
                    bodies[i].ay -= f * (dy / r);
                }
            }

            for (let i = 1; i < bodies.length; i++) {
                bodies[i].vx += bodies[i].ax * DT;
                bodies[i].vy += bodies[i].ay * DT;
                bodies[i].x += bodies[i].vx * DT;
                bodies[i].y += bodies[i].vy * DT;
            }
        }
    \end{minted}
    \caption{Kod obliczania kroku symulacji w języku JavaScript}
\end{listing}

Warto dodać, że nie jest to najbardziej optymalny algorytm z którego można było skorzystać, ponieważ nie było to celem tego testu.
Test ten miał sprawdzić czy nawet taki naiwny algorytm po przepisaniu do języka Rust uzyska przyspieszenie w działaniu.

\subsection{Rust}
Przedstawiony poniżej kod jest praktycznie odzwierciedleniem kodu napisanego w JavaScript.
Pokazuje to jak łatwo można przepisać istniejące funkcje JavaScript na język Rust bez specjalnych trudności.

\begin{listing}[H]
    \begin{minted}{rust}
        pub fn tick(&mut self) {
            for i in 1..self.bodies.len() {
                self.bodies[i].ax = 0.0;
                self.bodies[i].ay = 0.0;
    
                for j in 0..self.bodies.len() {
                    if i == j {
                        continue;
                    }
    
                    let dx = self.bodies[i].x - self.bodies[j].x;
                    let dy = self.bodies[i].y - self.bodies[j].y;
                    let r = (dx * dx + dy * dy).sqrt().max(self.e);
                    let f = self.g * self.bodies[j].mass / (r * r);
    
                    self.bodies[i].ax -= f * (dx / r);
                    self.bodies[i].ay -= f * (dy / r);
                }
            }
    
            for i in 1..self.bodies.len() {
                self.bodies[i].vx += self.bodies[i].ax * self.dt;
                self.bodies[i].vy += self.bodies[i].ay * self.dt;
                self.bodies[i].x += self.bodies[i].vx * self.dt;
                self.bodies[i].y += self.bodies[i].vy * self.dt;
            }
        }
    \end{minted}
    \caption{Kod obliczania kroku symulacji w języku Rust}
\end{listing}

Pominięto w tym kodzie funkcje pomocnicze tworzące klasę zawierającą funkcje przedstawioną powyżej.
Nie przedstawiona została również funkcja pomocnicza zwracająca aktualny stan symulacji dla modułu wyświetlającego napisanego w JavaScript.

\subsection{Wydajność}
Na wykresie \ref{fig:nbody} można zaobserwować, że wszystkie czasy były do siebie bardzo zbliżone.
Mimo wszystko jednak moduł WebAssembly napisany w języku Rust odnotował czasy gorsze o 0.5 milisekundy dla przeglądarki Chrome oraz 0.2 milisekundy dla Firefox.

\begin{figure}[H]
    \centering
    \import{plots}{nbody.pgf}
    \caption{Średnie czasy wykonania jednego kroku symulacji N ciał}
    \label{fig:nbody}
\end{figure}

\section{Wnioski}
Test ten pokazał, że WebAssembly nie będzie szybszy od JavaScript w każdym przypadku.
Silniki JavaScript zawarte w przeglądarkach są jedynymi z najlepiej zoptymalizowanych programów na świecie.
Wynika to z tego, że mało który kod jest tak często uruchamiany na komputerach jak ten odpowiadający za działanie większości stron internetowych.
Korzystają one z kompilacji \emph{JIT}\footnotemark{} (ang. just-in-time) dla funkcji, które są często używane.
\footnotetext{Kompilacja just-in-time -- sposób wykonywania kodu wymagający kompilacji programu w trakcie jego wykonywania}
Kompilator JIT potrafi generować bezpośrednio natywny kod maszynowy komputera na którym uruchamiany jest kod JavaScript.
Z tego powodu, w przypadku tego testu, wykonywał się on minimalnie szybciej niż jego odpowiednik w module WebAssembly.
Należy mieć tego świadomość tworząc aplikację internetową, gdyż korzystanie z WebAssembly w miejscach, w których nie do końca się do tego nadaje może nie przynieść żadnych korzyści.

\chapter{Interaktywna aplikacja webowa z użyciem WebAssembly}

\section{Przykładowa aplikacja}

\section{Porównanie wydajności}

\section{Aplikacja natywna}

\begin{figure}[H]
    \centering
    \import{plots}{edges.pgf}
    \caption{Czasy procesowania pojedynczej klatki}
    \label{fig:edges}
\end{figure}

\section{WebRTC vs WebSocket}

\chapter{Podsumowanie}

\backmatter

\cleardoublepage
\renewcommand\listoflistingscaption{Spis listingów}
\listoflistings

\cleardoublepage
\listoffigures

\cleardoublepage
\printbibliography

\end{document}
